"use strict";

(function () {
    window.dxGridExtensions = {
        isUndefinedOrNull: function isUndefinedOrNull(val) {
            return angular.isUndefined(val) || val === null;
        }
    };

    window.dxGridExtensions.groupCellTemplate = function (groupCell, info) {
        $('<div>').html(info.text).appendTo(groupCell);
    };

    window.dxGridExtensions.isInt = function (n) {
        return !isNaN(Number(n)) && Number(n) % 1 === 0;
    };

    window.dxGridExtensions.isFloat = function (n) {
        return !isNaN(Number(n)) && Number(n) % 1 !== 0;
    };

    window.dxGridExtensions.resetSelectBoxValue = function (selectBoxId) {

        var instance = $(selectBoxId).dxSelectBox("instance");
        if (dxGridExtensions.isUndefinedOrNull(instance)) return;
        instance.option("value", null);
    };

    window.dxGridExtensions.initFormulas = function (scope) {

        scope.AND = formulajs.AND;
        scope.OR = formulajs.OR;
        scope.NOT = formulajs.NOT;
        scope.IF = formulajs.IF;
        scope.ISNULL = formulajs.ISNULL;
        scope.CEILING = formulajs.CEILING;
        scope.EXP = formulajs.EXP;
        scope.FLOOR = formulajs.FLOOR;
        scope.MAX = formulajs.MAX;
        scope.MIN = formulajs.MIN;
        scope.POW = formulajs.POW;
        scope.RAND = formulajs.RAND;
        scope.RANDBETWEEN = formulajs.RANDBETWEEN;
        scope.ROUND = formulajs.ROUND;
        scope.SIGN = formulajs.SIGN;
        scope.DECIMAL = formulajs.DECIMAL;
        scope.INT = formulajs.INT;
        scope.CONCATENATE = formulajs.CONCATENATE;
        scope.CONTAINS = formulajs.CONTAINS;
        scope.LEN = formulajs.LEN;
        scope.LOWER = formulajs.LOWER;
        scope.MID = formulajs.MID;
        scope.TRIM = formulajs.TRIM;
        scope.UPPER = formulajs.UPPER;
        scope.TODAY = formulajs.TODAY;
        scope.WEEKDAY = formulajs.WEEKDAY;
        scope.MONTH = formulajs.MONTH;
        scope.YEAR = formulajs.YEAR;
    };
})();

angular.module('dxGridExtensionTemplates', []);
var dxGridExtension = angular.module('dxGridExtension', ['dx', 'ngRoute', 'dxGridExtensionTemplates']);
'use strict';

dxGridExtension.controller('columnChooser', function columnChooserCrtl($scope, $controller, $timeout, customColumnConfiguration) {

    $scope.columnChooserGrid;
    $scope.management.showColumnChooserConsole = false;
    $scope.getAllColumns = getAllColumns;
    $scope.getColumnFormat = getColumnFormat;

    $scope.columnChooserDataSource = new DevExpress.data.ArrayStore({
        data: []
    });

    $scope.$watch('management.showColumnChooserConsole', function () {

        if (!$scope.management.showColumnChooserConsole) return;

        $timeout(function () {

            $scope.columnChooserDataSource.clear();

            var data = [];
            var columns = getAllColumns();

            var i = 0;

            _.forEach(columns, function (column) {
                $scope.columnChooserDataSource.insert(createColumnChooserColumnData(column, i++));
            });

            $scope.columnChooserGrid.dxDataGrid("instance").refresh();
        }, 500);
    });

    $scope.columnChooserPopupOptions = {
        width: 800,
        contentTemplate: "info",
        height: "100%",
        dragEnabled: true,
        showTitle: true,
        closeOnOutsideClick: false,
        title: "Management - Columns",
        bindingOptions: {
            visible: "management.showColumnChooserConsole"
        }
    };

    $scope.columnChooserGridOptions = {
        dataSource: {
            store: $scope.columnChooserDataSource,
            sort: 'position'
        },
        height: "90%",
        width: '100%',
        resize: false,
        onContentReady: function onContentReady(e) {
            initDragging(e.element);
        },
        onInitialized: function onInitialized(e) {
            $scope.columnChooserGrid = e.element;
        },
        allowColumnResizing: true,
        scrolling: {
            mode: "virtual"
        },
        filterRow: { visible: true },
        sorting: { mode: 'none' },
        hoverStateEnabled: true,
        controlColumnResizing: false,
        showRowLines: true,
        showColumnLines: true,
        selection: {
            mode: "single"
        },
        onRowValidating: function onRowValidating(e) {
            e.valid = true;
        },
        onRowPrepared: function onRowPrepared(e) {
            if (e.rowType != 'data') return;
            e.rowElement.addClass('dragRow');
            e.rowElement.data('keyValue', e.key);
        },
        editing: {
            mode: "popup",
            allowUpdating: true,
            popup: {
                showTitle: false,
                width: 700,
                height: 345,
                position: {
                    my: "middle",
                    at: "middle",
                    of: window
                }
            }
        },
        columns: [{
            dataField: 'caption',
            caption: "Caption"
        }, {
            dataField: "hasAggregation",
            caption: "Aggregation",
            dataType: "boolean",
            allowFiltering: false
        }, {
            dataField: "visible",
            caption: "Visible",
            dataType: "boolean",
            allowFiltering: true
        }, {
            dataField: "format",
            caption: "Format",
            lookup: {
                allowClearing: false,
                dataSource: customColumnConfiguration.customColumnFormats,
                displayExpr: "text",
                valueExpr: "text"
            },
            allowFiltering: false
        }, {
            dataField: 'position',
            caption: "Position",
            visible: false,
            allowFiltering: false
        }]
    };

    $scope.columnChooserValidateButtonOptions = {
        text: 'Validate changes',
        onClick: function onClick() {

            $scope.columnChooserGrid.dxDataGrid('instance').saveEditData().then(function (result) {
                $scope.safeUpdate(function () {

                    _.forEach($scope.columnChooserDataSource._array, function (item) {

                        var column = _.find($scope.management.columns, function (col) {
                            return item.dataField === col.dataField;
                        });

                        column.visibleIndex = item.position;
                        column.caption = item.caption;
                        column.visible = item.visible;

                        if (item.hasAggregation) {
                            createAggregation(item.dataField);
                        } else {
                            removeAggregation(item.dataField);
                        }

                        var format = _.find(customColumnConfiguration.customColumnFormats, function (formatting) {
                            return formatting.text == item.format;
                        });

                        applyColumnFormating(column, format);
                    });

                    $timeout(function () {

                        $scope.management.instance.option('columns', $scope.management.columns);
                        if ($scope.canGroup) $scope.management.instance.option('summary.groupItems', $scope.management.groupItems);
                    }, 500);
                });
                $scope.management.showColumnChooserConsole = false;
            });
        }
    };

    function getColumnFormat(column) {

        return _.find(customColumnConfiguration.customColumnFormats, function (item) {

            if (item.value.dataType == column.dataType) {

                if (dxGridExtensions.isUndefinedOrNull(item.value.format)) return false;

                if (item.value.format.type == column.format.type && item.value.format.precision == column.format.precision) return true;
            }

            return false;
        });
    };

    function getAllColumns() {

        var columnCount = $scope.management.instance.columnCount();
        var columns = [];

        for (var i = 0; i < columnCount; i++) {
            columns.push($scope.management.instance.columnOption(i));
        }return columns;
    };

    function initDragging($gridElement) {

        $gridElement.find('.dragRow').draggable({
            helper: 'clone',
            scroll: true,
            axis: "y",
            drag: function drag(event, ui) {

                $timeout(function () {

                    var scrollDownOffset = $scope.columnChooserGrid.height() + $scope.columnChooserGrid.offset().top - 50;
                    var scrollUpOffset = $scope.columnChooserGrid.offset().top + 50;

                    if (ui.offset.top < scrollUpOffset) {
                        var scrollable = $scope.columnChooserGrid.dxDataGrid("instance").getScrollable();
                        var offset = scrollable.scrollOffset().top - 10 < 0 ? 0 : scrollable.scrollOffset().top - 10;
                        scrollable.scrollTo(offset);
                    }

                    if (ui.offset.top > scrollDownOffset) {
                        var scrollable = $scope.columnChooserGrid.dxDataGrid("instance").getScrollable();
                        var offset = scrollable.scrollOffset().top + 10;
                        scrollable.scrollTo(offset);
                    };
                });
            },
            start: function start(event, ui) {

                var originalRow = $(this);
                var clonedRow = ui.helper;
                var originalRowCells = originalRow.children();
                var clonedRowCells = clonedRow.children();

                for (var i = 0; i < originalRowCells.length; i++) {
                    $(clonedRowCells.get(i)).width($(originalRowCells.get(i)).width());
                }

                clonedRow.width(originalRow.width());
                clonedRow.addClass('drag-helper');
            }
        });

        $gridElement.find('.dragRow').droppable({
            drop: function drop(event, ui) {

                var draggingRowKey = ui.draggable.data('keyValue');
                var targetRowKey = $(this).data('keyValue');

                if (dxGridExtensions.isUndefinedOrNull(targetRowKey)) return;

                var draggingIndex = null;
                var targetIndex = null;
                $scope.columnChooserDataSource.byKey(draggingRowKey).done(function (item) {
                    draggingIndex = item.position;
                });
                $scope.columnChooserDataSource.byKey(targetRowKey).done(function (item) {
                    targetIndex = item.position;
                });
                var draggingDirection = targetIndex < draggingIndex ? 1 : -1;
                var dataItems = null;
                $scope.columnChooserDataSource.load().done(function (data) {
                    dataItems = data;
                });
                for (var dataIndex = 0; dataIndex < dataItems.length; dataIndex++) {
                    if (dataItems[dataIndex].position > Math.min(targetIndex, draggingIndex) && dataItems[dataIndex].position < Math.max(targetIndex, draggingIndex)) {
                        dataItems[dataIndex].position += draggingDirection;
                    }
                }

                $scope.columnChooserDataSource.update(draggingRowKey, { position: targetIndex });
                $scope.columnChooserDataSource.update(targetRowKey, { position: targetIndex + draggingDirection });

                $gridElement.dxDataGrid('instance').refresh();
            }
        });
    };

    function applyColumnFormating(column, format) {

        column.dataType = format.value.dataType;
        column.format = { type: null, precision: null };

        if (!dxGridExtensions.isUndefinedOrNull(format.value.format)) {
            column.format.type = format.value.format.type;
            column.format.precision = format.value.format.precision;
        }

        var groupItem = _.find($scope.management.groupItems, function (item) {
            return item.column === column.dataField;
        });

        if (!dxGridExtensions.isUndefinedOrNull(groupItem)) {

            if (dxGridExtensions.isUndefinedOrNull(format.value.format)) {
                groupItem.valueFormat.type = null;
                groupItem.valueFormat.precision = null;
            } else {
                groupItem.valueFormat.type = format.value.format.type;
                groupItem.valueFormat.precision = format.value.format.precision;
            }
        }
    };

    function removeAggregation(dataField) {

        _.remove($scope.management.groupItems, function (item) {
            return item.column === dataField;
        });
    };

    function createAggregation(dataField) {

        if (null == $scope.management.currentColumn || $scope.management.currentColumn.dataType == "string") return;

        var result = _.find($scope.management.groupItems, function (item) {
            return item.column === dataField;
        });

        if (!dxGridExtensions.isUndefinedOrNull(result)) return;

        var group = createDefaultNumberGroupItem(dataField);
        $scope.management.groupItems.push(group);
    };

    function createColumnChooserColumnData(column, id) {

        var format = getColumnFormat(column);

        return {
            id: id,
            dataField: column.dataField,
            caption: column.caption + '',
            visible: column.visible,
            hasAggregation: !dxGridExtensions.isUndefinedOrNull(_.find($scope.management.groupItems, function (group) {
                return group.column == column.dataField;
            })),
            position: column.visibleIndex,
            format: format.text
        };
    };
});
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

dxGridExtension.controller('conditionalFormatting', function conditionalFormattingCrtl($scope, $controller, $timeout, conditionalFormattingConfiguration, customColumnConfiguration) {
    var _$scope$conditionalFo;

    var defaultColor = "#ff2600";
    var defaultIcon = conditionalFormattingConfiguration.availableIcons[0];

    $scope.management.showConditionalFormattingConsole = false;

    $scope.conditionalFormatingGrid = null;
    $scope.conditionalFormattingResult = [];
    $scope.conditionalFormatingExpressionText = '';
    $scope.isExpressionDisabled = true;
    $scope.isCreateRuleDisabled = true;
    $scope.conditionalFormattingExpressionTargetedColumns = [];
    $scope.selectedExistingConditionalFormattingRule = null;

    $scope.conditionalFormatingTargetColumn = null;
    $scope.selectedConditionalFormattingRule = null;
    $scope.selectedConditionalFormattingRules = [];
    $scope.currentConditionalFormattingColor = defaultColor;
    $scope.selectedConditionalFormattingIcon = defaultIcon;

    //refacto handle use of customs column in expression
    // $scope.expressionCompliantColumns = [];

    $scope.management.conditionalFormattingRules = _.transform($scope.management.conditionalFormattingRules, function (result, item) {
        result.push(conditionalFormattingConfiguration.getRuleFromdescriptor(item));
    }, []);

    $scope.$watch('selectedConditionalFormattingIcon', function () {

        if (!dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) {
            $scope.selectedConditionalFormattingRule.icon = $scope.selectedConditionalFormattingIcon;
            applyRule();
        }
    });

    $scope.$watch('currentConditionalFormattingColor', function () {

        if (dxGridExtensions.isUndefinedOrNull($scope.currentConditionalFormattingColor) || dxGridExtensions.isUndefinedOrNull($scope.conditionalFormatingGrid) || dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) return;

        var grid = $scope.conditionalFormatingGrid.dxDataGrid('instance');

        if (dxGridExtensions.isUndefinedOrNull(grid)) return;

        $scope.selectedConditionalFormattingRule.color = $scope.currentConditionalFormattingColor;

        applyRule();
    });

    $scope.$watch('selectedConditionalFormattingRule', function () {

        updateCreateRuleDisabled();

        if (dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) return;

        $scope.isExpressionDisabled = !$scope.selectedConditionalFormattingRule.isExpressionBased;

        applyRule();
    });

    $scope.$watch('conditionalFormatingExpressionText', function () {

        updateCreateRuleDisabled();

        if (dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) return;

        if ($scope.conditionalFormatingExpressionText === '') {
            $scope.conditionalFormattingResult = [];
        }
    });

    $scope.$watch('management.showConditionalFormattingConsole', function () {

        if (!dxGridExtensions.isUndefinedOrNull($scope.conditionalFormatingGrid)) {
            var conditionalFormattingGrid = $scope.conditionalFormatingGrid.dxDataGrid('instance');
            conditionalFormattingGrid.option('dataSource', null);
        };

        $scope.conditionalFormatingExpressionText = '';
        $scope.selectedConditionalFormattingIcon = defaultIcon;
        $scope.currentConditionalFormattingColor = defaultColor;
        $scope.conditionalFormatingTargetColumn = null;

        dxGridExtensions.resetSelectBoxValue("#conditionFormatingTargetColumn");

        //refacto handle use of customs column in expression
        // $scope.expressionCompliantColumns = _.filter($scope.management.columns, (column) => {
        //     return !column.isCustomColumn;
        // });
    });

    $scope.$watch('conditionalFormatingTargetColumn', function () {

        updateCreateRuleDisabled();

        if (dxGridExtensions.isUndefinedOrNull($scope.conditionalFormatingTargetColumn)) return;

        applyRule();
    });

    $scope.$watch('selectedConditionalFormattingRules', function () {

        if ($scope.selectedConditionalFormattingRules.length == 0) return;

        $scope.selectedConditionalFormattingRule = $scope.selectedConditionalFormattingRules[0].items[0];
    });

    $scope.$watch('selectedExistingConditionalFormattingRule', function () {
        $scope.isExistingRuleActionDisabled = dxGridExtensions.isUndefinedOrNull($scope.selectedExistingConditionalFormattingRule);
    });

    $scope.conditionalFormattingAvailableColumnsSelectBoxOptions = {
        bindingOptions: {
            items: "management.columns",
            value: "selectedAvailableColumn",
            disabled: 'isExpressionDisabled'
        },
        displayExpr: "dataField",
        valueExpr: "dataField",
        onItemClick: function onItemClick(e) {
            $scope.conditionalFormatingExpressionText += '[' + e.itemData.dataField + ']';
            $scope.selectedAvailableColumn = null;
        },
        placeholder: "Add column to expression"
    };

    $scope.conditionalFormattingTestExpressionButtonOptions = {
        icon: 'fa fa-hacker-news',
        text: 'Test expression',
        bindingOptions: {
            disabled: 'isCreateRuleDisabled'
        },
        onClick: function onClick() {
            applyRule();
        }
    };

    $scope.conditionalFormattingPopupOptions = (_$scope$conditionalFo = {
        width: 750,
        contentTemplate: "info",
        showTitle: false,
        height: "auto"
    }, _defineProperty(_$scope$conditionalFo, 'showTitle', true), _defineProperty(_$scope$conditionalFo, 'title', "Management - Conditional Formatting"), _defineProperty(_$scope$conditionalFo, 'dragEnabled', true), _defineProperty(_$scope$conditionalFo, 'closeOnOutsideClick', true), _defineProperty(_$scope$conditionalFo, 'bindingOptions', {
        visible: "management.showConditionalFormattingConsole"
    }), _$scope$conditionalFo);

    $scope.conditionalFormattingExpressionTextBoxOptions = {
        bindingOptions: {
            value: "conditionalFormatingExpressionText",
            disabled: 'isExpressionDisabled'
        },
        placeholder: "Enter expression...",
        showClearButton: true
    };

    $scope.conditionalFormattingcreateButtonOptions = {
        icon: 'fa fa-hacker-news',
        text: 'Create expression',
        bindingOptions: {
            disabled: 'isCreateRuleDisabled'
        },
        onClick: function onClick(e) {
            $scope.conditionalFormattingCreateRule();
        }
    };

    $scope.conditionalFormattingAvailableTargetColumnsOptions = {
        bindingOptions: {
            items: "management.columns"
        },
        onItemClick: function onItemClick(e) {
            $scope.conditionalFormatingTargetColumn = e.itemData.dataField;
        },
        displayExpr: "dataField",
        placeholder: "Choose target column..."
    };

    $scope.conditionalFormattingResultGridPopupOptions = {
        bindingOptions: { dataSource: 'conditionalFormattingResult' },
        height: 350,
        resize: false,
        onInitialized: function onInitialized(e) {
            $scope.conditionalFormatingGrid = e.element;
        },
        allowColumnResizing: true,
        scrolling: {
            mode: "virtual"
        },
        loadPanel: {
            enabled: true
        },
        hoverStateEnabled: true,
        controlColumnResizing: true,
        showRowLines: true,
        showColumnLines: false,
        selection: {
            mode: "single"
        },
        sorting: {
            mode: "multiple"
        }
    };

    $scope.rulesListOptions = {
        bindingOptions: {
            selectedItems: 'selectedConditionalFormattingRules'
        },
        showSelectionControls: true,
        selectionMode: "single",
        selectAllMode: "allPages",
        items: conditionalFormattingConfiguration.availableRules,
        height: "50%",
        grouped: true,
        collapsibleGroups: true,
        groupTemplate: function groupTemplate(data) {
            return $("<div>Type: " + data.key + "</div>");
        }
    };

    $scope.conditionalFormattingColorBox = {
        bindingOptions: {
            value: "currentConditionalFormattingColor"
        },
        applyValueMode: "instantly"
    };

    $scope.condtionalFormattingAvailableIconsSelectBoxOptions = {
        dataSource: conditionalFormattingConfiguration.availableIcons,
        displayExpr: "name",
        valueExpr: "css",
        bindingOptions: {

            value: 'selectedConditionalFormattingIcon'
        },
        placeholder: 'Select an icon...'
    };

    $scope.conditionalFormattingDeleteExistingRuleButtonOptions = {
        text: 'Delete',
        bindingOptions: {
            disabled: 'isExistingRuleActionDisabled'
        },
        onClick: function onClick() {

            _.remove($scope.management.conditionalFormattingRules, { target: $scope.selectedExistingConditionalFormattingRule.target });

            $scope.management.instance.repaint();

            $scope.management.showConditionalFormattingConsole = false;
        }
    };

    $scope.conditionalFormattingLoadExistingRuleButtonOptions = {
        text: 'Load',
        bindingOptions: {
            disabled: 'isExistingRuleActionDisabled'
        },
        onClick: function onClick() {

            $scope.conditionalFormatingTargetColumn = $scope.selectedExistingConditionalFormattingRule.target;
            $scope.conditionalFormatingExpressionText = $scope.selectedExistingConditionalFormattingRule.expression;
            $scope.currentConditionalFormattingColor = $scope.selectedExistingConditionalFormattingRule.color;
            $scope.selectedConditionalFormattingIcon = $scope.selectedExistingConditionalFormattingRule.icon;

            $("#conditionalFormattingRuleList").dxList("instance").selectItem(_.find(conditionalFormattingConfiguration.getAllRules(), function (rule) {
                return rule.text == $scope.selectedExistingConditionalFormattingRule.text;
            }));
        }
    };

    $scope.conditionalFormattingExistingRulesSelectBoxOptions = {
        displayExpr: "target",
        bindingOptions: {
            dataSource: 'management.conditionalFormattingRules',
            value: 'selectedExistingConditionalFormattingRule'
        },
        placeholder: 'Load existing rule...'
    };

    function createRule() {

        return conditionalFormattingConfiguration.createRule($scope.selectedConditionalFormattingRule.text, $scope.conditionalFormatingTargetColumn, $scope.conditionalFormatingExpressionText, $scope.currentConditionalFormattingColor, $scope.selectedConditionalFormattingIcon);
    };

    function applyRule() {

        applyExpression();

        if (dxGridExtensions.isUndefinedOrNull($scope.conditionalFormatingGrid)) return;

        var grid = $scope.conditionalFormatingGrid.dxDataGrid('instance');

        if (dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) return;

        var rule = createRule();

        grid.option("onCellPrepared", function (options) {
            conditionalFormattingConfiguration.applyConditionalFormattingExpressionOnCell(options, rule, $scope.conditionalFormattingResult);
        });

        grid.repaint();
    };

    //refacto scoped for testing purpose
    $scope.conditionalFormattingCreateRule = function () {

        if (dxGridExtensions.isUndefinedOrNull($scope.management.instance)) return;

        var rule = createRule();

        _.remove($scope.management.conditionalFormattingRules, { target: rule.target });

        $scope.management.conditionalFormattingRules.push(rule);

        $scope.management.instance.repaint();

        $scope.management.showConditionalFormattingConsole = false;
    };

    function applyExpression() {

        try {

            $scope.conditionalFormattingResult = [];

            var expression = $scope.conditionalFormatingExpressionText;

            $scope.conditionalFormattingExpressionTargetedColumns = $scope.expression === '' ? [] : expression.match(/\[(.*?)\]/g);

            _.each($scope.management.datasource, function (row) {

                var conditionalFormatingresult = {};

                _.each($scope.conditionalFormattingExpressionTargetedColumns, function (column) {

                    var sourceColumn = column.substring(1, column.length - 1);

                    if (!row.hasOwnProperty(sourceColumn)) throw new Error("Column " + sourceColumn + " does not exist");

                    var customColum = _.find($scope.management.customColumns, function (c) {
                        return c.dataField == sourceColumn;
                    });

                    if (customColum) {
                        conditionalFormatingresult[sourceColumn] = customColumnConfiguration.computeCustomColumn(customColum.expression, row);
                    } else {
                        conditionalFormatingresult[sourceColumn] = row[sourceColumn];
                    }
                });

                var value = row[$scope.conditionalFormatingTargetColumn];

                var customColum = _.find($scope.management.customColumns, function (c) {
                    return c.dataField == $scope.conditionalFormatingTargetColumn;
                });

                if (customColum) {
                    value = customColumnConfiguration.computeCustomColumn(customColum.expression, row);
                }

                conditionalFormatingresult[$scope.conditionalFormatingTargetColumn] = value;

                $scope.conditionalFormattingResult.push(conditionalFormatingresult);
            });
        } catch (e) {

            $scope.conditionalFormattingResult.push({
                error: e.message
            });

            return;
        }
    };

    function updateCreateRuleDisabled() {

        if ($scope.conditionalFormatingTargetColumn == null || dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) {
            $scope.isCreateRuleDisabled = true;
            return;
        }

        if ($scope.selectedConditionalFormattingRule.isExpressionBased && $scope.conditionalFormatingExpressionText === '') {
            $scope.isCreateRuleDisabled = true;
            return;
        }

        $scope.isCreateRuleDisabled = false;
    };
});
'use strict';

dxGridExtension.controller('customColumns', function customColumnsCrtl($scope, $controller, $timeout, $log, customColumnConfiguration) {

    $scope.management.showCustomColumnConsole = false;

    $scope.customColumnGrid = null;
    $scope.customColumnExpressionText = '';
    $scope.customColumnName = null;
    $scope.customColumnResult = [];
    $scope.customColumnSelectedAvailableColumn = null;
    $scope.customColumnFormating = null;
    $scope.cannotCreateColumn = true;
    $scope.isExistingRuleActionDisabled = true;
    $scope.selectedExistingCustomColumn = null;
    $scope.isExistingCustomColumnActionDisabled = false;

    //refacto handle use of customs column in expression
    $scope.expressionCompliantColumns = [];

    $scope.$watch('management.showCustomColumnConsole', function () {

        if (!$scope.management.showCustomColumnConsole) return;
        if (!dxGridExtensions.isUndefinedOrNull($scope.customColumnGrid)) $scope.customColumnGrid.dxDataGrid('instance').option('dataSource', null);
        $scope.customColumnExpressionText = '';
        $scope.customColumnName = '';
        $scope.customColumnSelectedAvailableColumn = null;

        dxGridExtensions.resetSelectBoxValue("#customColumnAvailableColumnsFormat");
        dxGridExtensions.resetSelectBoxValue("#existingCustomColumns");

        //refacto handle use of customs column in expression
        $scope.expressionCompliantColumns = _.filter($scope.management.columns, function (column) {
            return !column.isCustomColumn;
        });

        $scope.selectedExistingCustomColumn = '';
        $scope.customColumnFormating = '';
    });

    $scope.$watch('customColumnExpressionText', function () {
        updateCanCreateColumn();
    });

    $scope.$watch('customColumnName', function () {
        updateCanCreateColumn();
    });

    $scope.$watch('customColumnFormating', function () {
        updateCanCreateColumn();
    });

    $scope.$watch('selectedExistingCustomColumn', function () {
        $scope.isExistingCustomColumnActionDisabled = dxGridExtensions.isUndefinedOrNull($scope.selectedExistingCustomColumn) || $scope.selectedExistingCustomColumn == '';
    });

    $scope.customColumnResultGridOptions = {
        bindingOptions: { dataSource: 'customColumnResult' },
        height: 200,
        resize: false,
        onInitialized: function onInitialized(e) {
            $scope.customColumnGrid = e.element;
        },
        allowColumnResizing: true,
        scrolling: {
            mode: "virtual"
        },
        loadPanel: {
            enabled: true
        },
        hoverStateEnabled: true,
        controlColumnResizing: true,
        showRowLines: true,
        showColumnLines: false,
        selection: {
            mode: "single"
        },
        sorting: {
            mode: "multiple"
        }
    };

    $scope.customColumnAvailableColumnsSelectBoxOptions = {
        bindingOptions: {
            items: "expressionCompliantColumns",
            value: "customColumnSelectedAvailableColumn"
        },
        displayExpr: "dataField",
        onItemClick: function onItemClick(e) {
            $scope.customColumnExpressionText += '[' + e.itemData.dataField + ']';
            $scope.customColumnSelectedAvailableColumn = null;
            dxGridExtensions.resetSelectBoxValue("#customColumnAvailableColumns");
        },
        placeholder: "Add column to expression"
    };

    $scope.customColumnAvailableFormattingSelectBoxOptions = {
        displayExpr: "text",
        valueExpr: "value",
        items: customColumnConfiguration.customColumnFormats,
        bindingOptions: {
            value: "customColumnFormating"
        },
        placeholder: "Choose column format"
    };

    $scope.customColumnPopupOptions = {
        width: 900,
        contentTemplate: "info",

        height: "auto",
        dragEnabled: true,
        showTitle: true,
        title: "Management - Custom Columns",
        closeOnOutsideClick: true,
        bindingOptions: {
            visible: "management.showCustomColumnConsole"
        }
    };

    $scope.customColumnNameTextBoxOptions = {
        bindingOptions: {
            value: "customColumnName"
        },
        placeholder: "Enter column name...",
        showClearButton: true
    };

    $scope.customColumnExpressionTextBoxOptions = {
        bindingOptions: {
            value: "customColumnExpressionText"
        },
        placeholder: "Enter expression...",
        showClearButton: true
    };

    $scope.customColumnTestExpressionButtonOptions = {
        icon: 'fa fa-hacker-news',
        text: 'Test expression',
        bindingOptions: {
            disabled: 'cannotCreateColumn'
        },
        onClick: applyExpression
    };

    $scope.customColumncreateRuleButtonOptions = {
        icon: 'fa fa-hacker-news',
        text: 'Create column',
        bindingOptions: {
            disabled: 'cannotCreateColumn'
        },
        onClick: function onClick(e) {
            $scope.customColumnCreateColumn();
        }
    };

    $scope.customColumndeleteExistingCustomColumnButtonOptions = {
        text: 'Delete',
        bindingOptions: {
            disabled: 'isExistingCustomColumnActionDisabled'
        },
        onClick: function onClick() {
            removeColumn($scope.selectedExistingCustomColumn.name);
            $scope.management.showCustomColumnConsole = false;
        }
    };

    $scope.customColumnloadExistingCustomColumnButtonOptions = {
        text: 'Load',
        bindingOptions: {
            disabled: 'isExistingCustomColumnActionDisabled'
        },
        onClick: function onClick() {
            $scope.customColumnName = $scope.selectedExistingCustomColumn.name;
            $scope.customColumnExpressionText = $scope.selectedExistingCustomColumn.expression;
            $scope.customColumnFormating = $scope.selectedExistingCustomColumn.formatting;
        }
    };

    $scope.customColumnExistingCustomColumnsSelectBoxOptions = {
        displayExpr: "name",
        bindingOptions: {
            dataSource: 'management.customColumns',
            value: 'selectedExistingCustomColumn'
        },
        placeholder: 'Load existing column...'
    };

    //refacto scoped for testing purpose
    $scope.customColumnCreateColumn = function () {

        applyExpression();

        if (dxGridExtensions.isUndefinedOrNull($scope.management.instance)) return;

        var column = customColumnConfiguration.createCustomColumn($scope.customColumnName, $scope.customColumnExpressionText, $scope.customColumnFormating, $scope.management.currentColumn.visibleIndex);

        removeColumn(column.name);

        addColumn(column);

        $scope.management.showCustomColumnConsole = false;
    };

    function addColumn(column) {

        $scope.management.customColumns.push(column);
        $scope.management.columns.push(column);

        if ($scope.customColumnFormating.dataType === 'number' && !dxGridExtensions.isUndefinedOrNull($scope.management.groupItems)) {

            $scope.management.groupItems.push({
                column: column.dataField,
                summaryType: "sum",
                showInGroupFooter: false,
                alignByColumn: true,
                valueFormat: {
                    type: $scope.customColumnFormating.format.type,
                    precision: $scope.customColumnFormating.format.precision
                },
                displayFormat: "{0}"
            });
        }
    };

    function removeColumn(name) {

        _.remove($scope.management.customColumns, { name: name });
        _.remove($scope.management.columns, { dataField: name });
        _.remove($scope.management.groupItems, { column: name });

        $scope.management.instance.repaint();
    };

    function applyExpression() {

        try {

            $scope.customColumnResult = [];

            var expression = $scope.customColumnExpressionText;
            var customColumnExpressionTargetedColumns = expression.match(/\[(.*?)\]/g);

            _.each($scope.management.datasource, function (item) {

                var customColumnResult = {};

                _.each(customColumnExpressionTargetedColumns, function (column) {

                    var sourceColumn = column.substring(1, column.length - 1);

                    if (!item.hasOwnProperty(sourceColumn)) {
                        throw new Error("Column " + sourceColumn + " does not exist");
                    }

                    customColumnResult[sourceColumn] = item[sourceColumn];
                });

                customColumnResult[$scope.customColumnName] = customColumnConfiguration.computeCustomColumn(expression, item);

                $scope.customColumnResult.push(customColumnResult);
            });

            if (dxGridExtensions.isUndefinedOrNull($scope.customColumnGrid)) return;

            //important
            $timeout(function () {

                var grid = $scope.customColumnGrid.dxDataGrid('instance');
                grid.columnOption($scope.customColumnName, 'dataType', $scope.customColumnFormating.dataType);

                if ($scope.customColumnFormating.format != null) {

                    grid.columnOption($scope.customColumnName, 'format', {
                        type: $scope.customColumnFormating.format.type,
                        precision: $scope.customColumnFormating.format.precision
                    });
                }
            }, 500);
        } catch (e) {

            $scope.customColumnResult.push({
                error: e.message
            });

            return;
        }
    };

    function updateCanCreateColumn() {
        $scope.cannotCreateColumn = $scope.customColumnFormating == '' || $scope.customColumnExpressionText == '' || dxGridExtensions.isUndefinedOrNull($scope.customColumnName) || dxGridExtensions.isUndefinedOrNull($scope.customColumnFormating);
    };
});
"use strict";

dxGridExtension.controller('columnManagement', function columnManagementCrtl($scope, $controller, $timeout, customColumnConfiguration) {

    $scope.management.showColumnManagementConsole = false;
    $scope.columnManagementColumnName;
    $scope.columnManagementColumnFormating;
    $scope.cannotValidateChange;

    $scope.columnManagementPopupOptions = {
        width: 350,
        contentTemplate: "info",
        height: "auto",
        dragEnabled: true,
        showTitle: true,
        closeOnOutsideClick: true,
        bindingOptions: {
            visible: "management.showColumnManagementConsole",
            title: "columnManagementColumnName"
        }
    };

    $scope.$watch('management.showColumnManagementConsole', function () {

        if (dxGridExtensions.isUndefinedOrNull($scope.management.currentColumn) || !$scope.management.showColumnManagementConsole) return;

        $scope.columnManagementColumnName = $scope.management.currentColumn.caption;

        $scope.columnManagementColumnFormating = _.find(customColumnConfiguration.customColumnFormats, function (item) {

            if (item.value.dataType == $scope.management.currentColumn.dataType) {

                if (!dxGridExtensions.isUndefinedOrNull($scope.management.currentColumn.format)) {

                    if (dxGridExtensions.isUndefinedOrNull(item.value.format)) return false;

                    if (item.value.format.type == $scope.management.currentColumn.format.type && item.value.format.precision == $scope.management.currentColumn.format.precision) return true;
                } else {
                    if (dxGridExtensions.isUndefinedOrNull(item.value.format)) return true;
                }
            }

            return false;
        });
    });

    $scope.$watch('columnManagementColumnName', function () {
        $scope.cannotValidateChange = $scope.columnManagementColumnName == '';
    });

    $scope.columnManagementColumnNameTextBoxOptions = {
        bindingOptions: {
            value: "columnManagementColumnName"
        },
        onInput: function onInput(e) {
            $scope.cannotValidateChange = e.component._options.text == '';
        },
        showClearButton: true
    };

    $scope.columnManagementAvailableFormattingSelectBoxOptions = {
        displayExpr: "text",
        items: customColumnConfiguration.customColumnFormats,
        bindingOptions: {
            value: "columnManagementColumnFormating"
        }
    };

    $scope.columnManagementValidateButtonOptions = {
        text: 'Validate changes',
        bindingOptions: {
            disabled: 'cannotValidateChange'
        },
        onClick: function onClick() {
            $scope.columnManagementValidate();
        }
    };

    $scope.columnManagementValidate = function () {

        $scope.safeUpdate(function () {

            $scope.management.instance.columnOption($scope.management.currentColumn.dataField, 'caption', $scope.columnManagementColumnName);
            $scope.management.instance.columnOption($scope.management.currentColumn.dataField, 'dataType', $scope.columnManagementColumnFormating.value.dataType);
            $scope.management.instance.columnOption($scope.management.currentColumn.dataField, 'format', { type: null, precision: null });

            if (!dxGridExtensions.isUndefinedOrNull($scope.columnManagementColumnFormating.value.format)) {
                $scope.management.instance.columnOption($scope.management.currentColumn.dataField, 'format.type', $scope.columnManagementColumnFormating.value.format.type);
                $scope.management.instance.columnOption($scope.management.currentColumn.dataField, 'format.precision', $scope.columnManagementColumnFormating.value.format.precision);
            }

            var groupItem = _.find($scope.management.groupItems, function (item) {
                return item.column === $scope.management.currentColumn.dataField;
            });

            if (!dxGridExtensions.isUndefinedOrNull(groupItem)) {

                if (dxGridExtensions.isUndefinedOrNull($scope.columnManagementColumnFormating.value.format)) {
                    groupItem.valueFormat.type = null;
                    groupItem.valueFormat.precision = null;
                } else {
                    groupItem.valueFormat.type = $scope.columnManagementColumnFormating.value.format.type;
                    groupItem.valueFormat.precision = $scope.columnManagementColumnFormating.value.format.precision;
                }
            }
        });

        $scope.management.showColumnManagementConsole = false;
    };
});
'use strict';

dxGridExtension.controller('baseGridManagement', function baseGridManagementCrtl($scope, attributes, element, parent, customColumnConfiguration, conditionalFormattingConfiguration, $controller, $timeout) {

    initialize();

    $scope.isRestoreRunning = false;

    $scope.safeUpdate = function (action) {
        $scope.management.instance.beginUpdate();
        action();
        $scope.management.instance.endUpdate();
    };

    $scope.$watch($scope.management.options.bindingOptions.columns, function () {

        if (!$scope.canGroup) return;

        var columns = getConfig('columns');
        var groupItems = getConfig('groupItems');

        var groups = _.transform(columns, function (aggregate, item) {

            if (item.dataType === "number") {

                var existingGroup = _.find(groupItems, function (group) {
                    return item.column == item.dataField;
                });

                if (!dxGridExtensions.isUndefinedOrNull(existingGroup)) {
                    aggregate.push(groupItem);
                } else {

                    var groupItem = createDefaultNumberGroupItem(item.dataField);
                    aggregate.push(groupItem);
                }
            }
        }, []);

        setConfig('groupItems', groups);
    });

    $scope.$watch($scope.management.options.bindingOptions.dataSource, function () {

        if (dxGridExtensions.isUndefinedOrNull($scope.management.datasource) || $scope.management.datasource.length == 0) return;

        var template = $scope.management.datasource[0];

        var index = 0;

        var columns = _.transform(Object.keys(template), function (aggregate, field) {

            var columnOption = {
                dataField: field,
                caption: field,
                dataType: "string",
                visibleIndex: index++,
                format: { type: '', precision: 0 }
            };

            var existingColumn = _.find(getConfig('columns'), function (c) {
                return c.dataField == field;
            });

            if (!dxGridExtensions.isUndefinedOrNull(existingColumn)) {

                aggregate.push(existingColumn);
            } else {

                for (var i = 0; i < $scope.management.datasource.length; i++) {

                    if (!dxGridExtensions.isUndefinedOrNull($scope.management.datasource[i][field])) {

                        if (typeof $scope.management.datasource[i][field] === "boolean") {
                            columnOption.dataType = "boolean";
                            break;
                        }

                        if (dxGridExtensions.isInt($scope.management.datasource[i][field])) {
                            columnOption.dataType = "number";
                            columnOption.format = { type: 'fixedpoint', precision: 0 };
                            break;
                        }

                        if (dxGridExtensions.isFloat($scope.management.datasource[i][field])) {
                            columnOption.dataType = "number";
                            columnOption.summaryType = "sum";
                            columnOption.format = { type: 'fixedpoint', precision: 2 };
                            break;
                        }

                        columnOption.dataType = "string";
                        columnOption.format = { type: '', precision: 0 };

                        break;
                    }
                };

                columnOption.isCustomColumn = false;

                aggregate.push(columnOption);
            }
        }, []);

        _.each(getConfig('customColumns'), function (customColumn) {
            var _this = this;

            var column = _.find(getConfig('columns'), function (c) {
                return c.dataField == customColumn.name;
            });

            column.isCustomColumn = true;

            column.calculateCellValue = function (data) {
                return customColumnConfiguration.computeCustomColumn(_this.rule, data);
            };

            column.rule = customColumn.rule;
        });

        setConfig('columns', columns);
    });

    function setConfig(key, value) {
        $scope.management[key] = value;
    };

    function getConfig(index) {
        return $scope.management[index];
    };

    function addEventHandler(ev, handler) {

        var grid = getGridInstance();
        var current = grid.option(ev);

        grid.option(ev, function (options) {
            if (null != current) current(options);
            handler(options);
        });
    };

    function initialize() {

        $scope.self = parent;

        if (dxGridExtensions.isUndefinedOrNull($scope.self.gridManagement)) {
            $scope.self.gridManagement = {};
        }

        $scope.management = $scope.self.gridManagement[attributes.instance] = {};

        $scope.management.columns = [];
        $scope.management.groupItems = [];
        $scope.management.customColumns = [];
        $scope.management.conditionalFormattingRules = [];

        $scope.management.instance = $scope.self[attributes.instance];

        $scope.management.name = attributes.instance;
        $scope.management.options = $scope.self[attributes.options];

        $scope.management.datasource = $scope.self[attributes.datasource];

        $scope.$control = element;

        if (dxGridExtensions.isUndefinedOrNull($scope.management.options.bindingOptions)) {
            $scope.management.options.bindingOptions = {};
        }

        $scope.management.options.bindingOptions.dataSource = 'management.datasource';
        $scope.management.options.bindingOptions.columns = 'management.columns';

        if ($scope.canGroup) $scope.management.options.bindingOptions['summary.groupItems'] = 'management.groupItems';

        var columns = dxGridExtensions.isUndefinedOrNull(getConfig('columns')) ? null : getConfig('columns');
        setConfig('columns', columns);

        if ($scope.canGroup) {
            var groupItems = dxGridExtensions.isUndefinedOrNull(getConfig('groupItems')) ? null : getConfig('groupItems');
            if (!$scope.canGroup) setConfig('groupItems', groupItems);
        }

        $scope.management.save = function () {
            return {
                columns: $scope.management.columns,
                conditionalFormattingRules: $scope.management.conditionalFormattingRules,
                customColumns: $scope.management.customColumns,
                groupItems: $scope.management.groupItems,
                name: $scope.management.name,
                state: $scope.canGroup ? $scope.management.instance.state() : null
            };
        };

        $scope.management.restore = function (layout) {

            $scope.isRestoreRunning = true;

            $scope.safeUpdate(function () {

                $scope.management.conditionalFormattingRules = _.transform(layout.conditionalFormattingRules, function (aggregate, rule) {

                    aggregate.push(conditionalFormattingConfiguration.createRule(rule.text, rule.target, rule.expression, rule.color, rule.icon));
                }, []);

                $scope.management.customColumns = _.transform(layout.customColumns, function (aggregate, column) {

                    aggregate.push(customColumnConfiguration.createCustomColumn(column.name, column.expression, column.formatting, column.visibleIndex));
                }, []);

                $scope.management.columns = _.transform(layout.columns, function (aggregate, column) {

                    if (column.isCustomColumn) {
                        var customColumn = _.find($scope.management.customColumns, function (custom) {
                            return custom.dataField == column.dataField;
                        });
                        aggregate.push(customColumn);
                    } else {
                        aggregate.push(column);
                    }
                }, []);

                if ($scope.canGroup) {

                    $scope.management.groupItems = layout.groupItems;
                    $scope.management.instance.state(layout.state);
                }
            });

            $scope.isRestoreRunning = false;
            // $scope.management.instance.refresh();
            // $scope.management.instance.repaint();
        };

        $timeout(function () {

            var grid = getGridInstance();

            if (dxGridExtensions.isUndefinedOrNull(grid.option("onCellPrepared"))) {
                addEventHandler("onCellPrepared", function (options) {
                    _.each(getConfig('conditionalFormattingRules'), function (rule) {
                        conditionalFormattingConfiguration.applyConditionalFormattingExpressionOnCell(options, rule, $scope.management.datasource, $scope.management.customColumns);
                    });
                });
            }

            addEventHandler("onContentReady", function (e) {

                if ($scope.isRestoreRunning) return;

                //keep sync with internal dxDataGrid processes (column chooser, column position change...)
                _.each($scope.management.columns, function (column) {
                    column.visible = e.component.columnOption(column.dataField, "visible");
                    column.visibleIndex = e.component.columnOption(column.dataField, "visibleIndex");

                    if (column.isCustomColumn) {
                        var customColumn = _.find($scope.management.customColumns, function (custom) {
                            return custom.dataField == column.dataField;
                        });

                        customColumn.visible = column.visible;
                        customColumn.visibleIndex = column.visibleIndex;
                    }
                });
            });

            addEventHandler("onContextMenuPreparing", function (options) {
                if (options.row && options.row.rowType === 'data') {
                    options.items = getGridMenuItems(options);
                }
            });

            addEventHandler("customizeColumns", function (columns) {
                _.each(columns, function (column) {
                    column.groupCellTemplate = window.dxGridExtensions.groupCellTemplate;
                });
            });
        });
    };

    function getGridInstance() {
        if (dxGridExtensions.isUndefinedOrNull($scope.$control)) return null;
        try {
            //if the grid has been rendered
            var grid = $scope.self[$scope.management.name].NAME ? $scope.self[$scope.management.name] : $scope.getDevExpressControl();
            if ($scope.management.instance !== grid) {
                $scope.management.instance = $scope.self[$scope.management.name] = grid;
                $timeout(function () {
                    return $scope.management.instance.repaint();
                });
            }
            return grid;
        } catch (ex) {
            return null;
        }
    };

    function getGridMenuItems(element) {

        $scope.management.currentColumn = element.column;
        $scope.management.currentRow = element.row;

        var menu = [{
            text: 'Management - Columns',
            onItemClick: function onItemClick() {
                $scope.management.showColumnChooserConsole = true;
            }
        }, {
            text: 'Management - Conditional Formatting',
            onItemClick: function onItemClick() {
                $scope.management.showConditionalFormattingConsole = true;
            }
        }, {
            text: 'Management - Custom Columns',
            onItemClick: function onItemClick() {
                $scope.management.showCustomColumnConsole = true;
            }
        }, {
            text: 'Current Column - Modify',
            onItemClick: function onItemClick() {
                $scope.management.showColumnManagementConsole = true;
            }
        }];

        if ($scope.canGroup) {

            menu.push({
                text: 'Current Column - Remove Aggregation',
                onItemClick: function onItemClick() {
                    _.remove($scope.management.groupItems, function (item) {
                        return item.column === $scope.management.currentColumn.dataField;
                    });
                }
            });

            menu.push({
                text: 'Current Column - Create Aggregation',
                onItemClick: function onItemClick() {

                    if (null == $scope.management.currentColumn || $scope.management.currentColumn.dataType == "string") return;

                    var groupItems = getConfig('groupItems');

                    if (dxGridExtensions.isUndefinedOrNull(groupItems)) return;

                    var result = _.find($scope.self.gridManagement.groupItems, function (item) {
                        return item.column === $scope.management.currentColumn.dataField;
                    });

                    if (!dxGridExtensions.isUndefinedOrNull(result)) return;

                    var group = createDefaultNumberGroupItem($scope.management.currentColumn.dataField);
                    $scope.management.groupItems.push(group);
                }
            });
        }

        return menu;
    };

    function createDefaultNumberGroupItem(name) {
        return {
            column: name,
            summaryType: "sum",
            showInGroupFooter: false,
            alignByColumn: true,
            valueFormat: { type: 'fixedpoint', precision: 2 },
            displayFormat: "{0}"
        };
    };

    $controller('columnManagement', { $scope: $scope });
    $controller('conditionalFormatting', { $scope: $scope });
    $controller('columnChooser', { $scope: $scope });
    $controller('customColumns', { $scope: $scope });
});
'use strict';

dxGridExtension.directive('flatGrid', function () {
    return {
        restrict: "E",
        templateUrl: 'view.grid.flat.html',
        scope: true,
        controller: function controller($scope, $attrs, $element, $controller) {

            $scope.getDevExpressControl = function () {
                return $scope.$control.find('#flatGrid').dxDataGrid("instance");
            };

            $scope.canGroup = true;

            $controller('baseGridManagement', {
                $scope: $scope,
                attributes: $attrs,
                element: $element,
                parent: $scope.$parent
            });
        }
    };
});
'use strict';

dxGridExtension.directive('gridManagement', function () {
    return {
        restrict: "E",
        templateUrl: 'view.grid.management.html'
    };
});
'use strict';

dxGridExtension.directive('treeGrid', function () {
    return {
        restrict: "E",
        templateUrl: 'view.grid.tree.html',
        scope: true,
        controller: function controller($scope, $attrs, $element, $controller) {

            $scope.getDevExpressControl = function () {
                return $scope.$control.find('#treeGrid').dxTreeList("instance");
            };

            $scope.canGroup = false;

            $controller('baseGridManagement', {
                $scope: $scope,
                attributes: $attrs,
                element: $element,
                parent: $scope.$parent
            });
        }

    };
});
'use strict';

angular.module('dxGridExtensionTemplates').run(['$templateCache', function ($templateCache) {
  $templateCache.put('view.grid.flat.html', '<div id="flatGrid" dx-data-grid="management.options"></div>\r\n<grid-management></grid-management>');
  $templateCache.put('view.grid.management.html', '<div class="popup" id="conditionalFormattingConsole" dx-popup="conditionalFormattingPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div style="margin:5px;min-height:30px">\r\n            <div class="dx-fieldset">\r\n                <div class="dx-fieldset-header">Select an existing rule..</div>\r\n                <div class="dx-field">\r\n                    <div class="field-container">\r\n                        <div style="float:left;width:50%;" id="existingConditionalFormattingRules" dx-select-box="conditionalFormattingExistingRulesSelectBoxOptions"></div>\r\n                        <div style="float:right;width:20%;" dx-button="conditionalFormattingDeleteExistingRuleButtonOptions"></div>\r\n                        <div style="float:right;width:20%;" dx-button="conditionalFormattingLoadExistingRuleButtonOptions"></div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class="dx-fieldset">\r\n                <div class="dx-fieldset-header">...or create a new one</div>\r\n                <div class="dx-field">\r\n                    <div class="field-container">\r\n                        <div style="float:left;width:49%;margin-right:5px;" id="conditionFormatingTargetColumn" dx-select-box="conditionalFormattingAvailableTargetColumnsOptions"></div>\r\n                        <div style="float:right;width:50%;" dx-select-box="conditionalFormattingAvailableColumnsSelectBoxOptions"></div>\r\n                    </div>\r\n                    <div style="float:left;width:100%;margin-top:5px;" dx-text-box="conditionalFormattingExpressionTextBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="field-container">\r\n                <div style="margin:5px;float:left;width:65%;">\r\n                    <div style="top:50px;margin:5px;width:100%;" id="ruleTestingGrid" dx-data-grid="conditionalFormattingResultGridPopupOptions"></div>\r\n                </div>\r\n                <div style="margin:5px;float:right;width:30%;">\r\n                    <div id="conditionalFormattingRuleList" dx-list="rulesListOptions"></div>\r\n                    <div style="margin-top:10px;" dx-color-box="conditionalFormattingColorBox"></div>\r\n                    <div style="margin-top:10px;" dx-select-box="condtionalFormattingAvailableIconsSelectBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="field-container">\r\n                <div style="float:left;width:48%;margin-bottom:20px;" dx-button="conditionalFormattingTestExpressionButtonOptions"></div>\r\n                <div style="float:right;width:48%;margin-bottom:20px;" dx-button="conditionalFormattingcreateButtonOptions"></div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="customColumnConsole" dx-popup="customColumnPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div class="dx-fieldset">\r\n            <div class="dx-fieldset-header">Select an existing custom column...</div>\r\n            <div class="dx-field">\r\n                <div style="width:100%;min-height:30px;">\r\n                    <div style="float:left;width:40%;" id="existingCustomColumns" dx-select-box="customColumnExistingCustomColumnsSelectBoxOptions"></div>\r\n                    <div style="float:right;width:28%;margin:0px;" dx-button="customColumndeleteExistingCustomColumnButtonOptions"></div>\r\n                    <div style="float:right;width:27%;margin:0px 5px 0px 0px;" dx-button="customColumnloadExistingCustomColumnButtonOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class="dx-fieldset">\r\n            <div class="dx-fieldset-header">...or create a new one</div>\r\n            <div class="dx-field">\r\n                <div style="width:100%;min-height:30px;">\r\n                    <div style="float:left;width:25%;margin-right:5px;" id="customColumnColumnName" dx-text-box="customColumnNameTextBoxOptions"></div>\r\n                    <div style="float:left;width:35%;" id="customColumnAvailableColumnsFormat" dx-select-box="customColumnAvailableFormattingSelectBoxOptions"></div>\r\n                    <div style="float:right;width:35%;" id="customColumnAvailableColumns" dx-select-box="customColumnAvailableColumnsSelectBoxOptions"></div>\r\n                </div>\r\n                <div style="width:100%;" dx-text-box="customColumnExpressionTextBoxOptions"></div>\r\n                <div style="width:100%;margin-top:5px;min-height:30px;">\r\n                    <div style="float:left;width:50%;margin:0px 5px 0px 0px;" dx-button="customColumnTestExpressionButtonOptions"></div>\r\n                    <div style="float:right;width:49%;margin:0px" dx-button="customColumncreateRuleButtonOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div style="margin-top:10px;">\r\n            <div style="bottom:0;margin:5px;width:100%;" id="customColumnTestingGrid" dx-data-grid="customColumnResultGridOptions"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="columnManagementPopup" dx-popup="columnManagementPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div class="dx-fieldset">\r\n            <div class="dx-field">\r\n                <div class="dx-field-label">Name</div>\r\n                <div class="dx-field-value">\r\n                    <div dx-text-box="columnManagementColumnNameTextBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="dx-field">\r\n                <div class="dx-field-label">Format</div>\r\n                <div class="dx-field-value">\r\n                    <div id="columnManagementAvailableColumnsFormat" dx-select-box="columnManagementAvailableFormattingSelectBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div style="width:100%;margin-top:5px;min-height:30px;">\r\n            <div id="columnManagementValidateButton" style="width:100%;margin:0px" dx-button="columnManagementValidateButtonOptions"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="columnChooserConsole" dx-popup="columnChooserPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div id="columnChooserGrid" style="margin:10px" dx-data-grid="columnChooserGridOptions"></div>\r\n        <div style="width:100%;margin-top:10px;min-height:30px;" dx-button="columnChooserValidateButtonOptions"></div>\r\n    </div>\r\n</div>\r\n');
  $templateCache.put('view.grid.tree.html', '<div id="treeGrid" dx-tree-list="management.options"></div>\r\n<grid-management></grid-management>');
}]);
'use strict';

dxGridExtension.factory('conditionalFormattingConfiguration', function ($log, customColumnConfiguration) {

    function applyConditionalFormattingExpressionOnCell(cell, rule, dataSource, customColumns) {

        try {
            if (cell.rowType == 'data' && !dxGridExtensions.isUndefinedOrNull(rule) && !dxGridExtensions.isUndefinedOrNull(cell.value) && rule.target == cell.column.dataField && cell.data != null) {

                var self = this;

                if (rule.isExpressionBased) {

                    var expression = rule.expression;
                    var replacement = {};
                    var processedExpression = expression;

                    var row = cell.row.data;

                    _.forEach(row, function (value, key) {

                        dxGridExtensions.initFormulas(self);

                        var replacement = typeof value === "string" ? "'" + value + "'" : value;

                        var sum = _.sumBy(dataSource, function (o) {
                            return o[rule.target] != null && o[rule.target] > 0 ? o[rule.target] : 0;
                        });

                        var customColum = _.find(customColumns, function (column) {
                            return column.dataField == key;
                        });

                        if (customColum) {

                            replacement = customColumnConfiguration.computeCustomColumn(customColum.expression, row);

                            sum = _.sumBy(dataSource, function (obj) {
                                return customColumnConfiguration.computeCustomColumn(customColum.expression, obj);
                            });
                        }

                        processedExpression = processedExpression.split('[' + key + ']').join(" " + replacement + " ");
                    });

                    var result = eval(processedExpression);

                    if (result) rule.formatting(cell, cell.value, sum, rule);
                } else {

                    var value = cell.value;

                    var sum = _.sumBy(dataSource, function (o) {
                        return o[rule.target] != null && o[rule.target] > 0 ? o[rule.target] : 0;
                    });

                    var customColum = _.find(customColumns, function (column) {
                        return column.dataField == cell.column.dataField;
                    });

                    if (customColum) {
                        value = customColumnConfiguration.computeCustomColumn(customColum.expression, cell.row.data);

                        sum = _.sumBy(dataSource, function (obj) {
                            return customColumnConfiguration.computeCustomColumn(customColum.expression, obj);
                        });
                    }

                    rule.formatting(cell, value, sum, rule);
                }
            };
        } catch (e) {
            $log.error(e);
        }
    };

    //refacto : otherway arround, list of rules to menu 
    var rules = [{
        "key": "Auto set",
        "items": [{
            text: "Proportional Bars",
            isExpressionBased: false,
            formatting: function formatting(options, value, sum, rule) {

                if (options.column.dataType != 'number') return;

                if (value < 0) return;

                var fieldHtml = "<div><div class='formatting bar superpose' style='background:" + rule.color + ";width:" + value / sum * 100 + "%;''></div> <div class='formatting superpose'  style='z-index: 10;margin-top:-16px;'>" + options.text + "  </div></div>";

                options.cellElement.html(fieldHtml);
            }
        }, {
            text: "Up/Down colors",
            isExpressionBased: false,
            formatting: function formatting(options, value, sum, rule) {

                if (options.column.dataType != 'number') return;

                if (value > 0) {
                    options.cellElement.css("color", "green");
                } else {

                    options.cellElement.css("color", "red");
                }
            }
        }, {
            text: "Up/Down icon",
            isExpressionBased: false,
            formatting: function formatting(options, value, sum, rule) {

                if (options.column.dataType != 'number') return;

                if (value > 0) {
                    options.cellElement.append('<span class="cb cb-chevron-up" style="color:green;"></span>');
                } else {

                    options.cellElement.append('<span class="cb cb-chevron-down" style="color:red;"></span>');
                }
            }
        }]
    }, {
        "key": "Expression based",
        "items": [{
            text: "Text color",
            isExpressionBased: true,
            formatting: function formatting(options, value, sum, rule) {
                $(options.cellElement[0]).css("color", rule.color);
            }
        }, {
            text: "Background Color",
            isExpressionBased: true,
            formatting: function formatting(options, value, sum, rule) {
                $(options.cellElement[0]).css("background-color", rule.color);
            }
        }, {
            text: "Icon",
            isExpressionBased: true,
            formatting: function formatting(options, value, sum, rule) {
                options.cellElement.append('<span class="' + rule.icon + '" style="color: ' + rule.color + ';"></span>');
            }
        }]
    }];

    var icons = [{
        name: "Arrow up",
        css: 'cb cb-arrow-up'
    }, {
        name: "Arrow down",
        css: 'cb cb-arrow-down'
    }, {
        name: "Chevron up",
        css: 'cb cb-chevron-up'
    }, {
        name: "Chevron down",
        css: 'cb cb-chevron-down'
    }, {
        name: "Spin up",
        css: 'cb cb-spin-up'
    }, {
        name: "Spin down",
        css: 'cb cb-spin-down'
    }, {
        name: "Favorites",
        css: 'cb cb-favorites'
    }, {
        name: "Like",
        css: 'cb cb-like'
    }, {
        name: "Info",
        css: 'cb cb-info'
    }, {
        name: "Todo",
        css: 'cb cb-todo'
    }];

    var getRuleTemplate = function getRuleTemplate(name) {

        var allRules = getAllRules();

        var template = _.find(allRules, function (rule) {
            return rule.text === name;
        });

        return _.clone(template);
    };

    var getRuleFromdescriptor = function getRuleFromdescriptor(descriptor) {

        var rule = getRuleTemplate(descriptor.text);

        return _.extend(rule, descriptor);
    };

    var getAllRules = function getAllRules() {
        return _.transform(rules, function (result, group) {
            _.each(group.items, function (rule) {
                result.push(rule);
            }, []);
        });
    };

    var createRule = function createRule(name, target, expression, color, icon) {

        var rule = getRuleTemplate(name);

        if (dxGridExtensions.isUndefinedOrNull(rule)) throw new Error("Rule " + name + " does not exist");

        rule.target = target;
        rule.expression = expression;
        rule.color = color;
        rule.icon = icon;

        return rule;
    };

    return {
        getRuleFromdescriptor: getRuleFromdescriptor,
        createRule: createRule,
        applyConditionalFormattingExpressionOnCell: applyConditionalFormattingExpressionOnCell,
        getAllRules: getAllRules,
        availableRules: rules,
        availableIcons: icons
    };
});
"use strict";

dxGridExtension.service('customColumnConfiguration', function ($log) {

    this.createCustomColumn = function (name, expression, formatting, visibleIndex) {
        var _this = this;

        return {
            name: name,
            expression: expression,
            formatting: formatting,
            dataField: name,
            caption: name,
            isCustomColumn: true,
            dataType: formatting.dataType,
            format: { type: formatting.format.type, precision: formatting.format.precision },
            visibleIndex: visibleIndex,
            calculateCellValue: function calculateCellValue(data) {
                return _this.computeCustomColumn(expression, data);
            }
        };
    };

    this.computeCustomColumn = function (expression, data) {

        try {

            var replacement = {};
            var processedExpression = expression;

            dxGridExtensions.initFormulas(this);

            _.forEach(data, function (value, key) {

                var replacement = typeof value === "string" ? "'" + value + "'" : value;
                processedExpression = processedExpression.split('[' + key + ']').join(" " + replacement + " ");
            });

            return eval(processedExpression);
        } catch (e) {
            $log.error(e);
        }
    };

    this.customColumnFormats = [{
        text: "string",
        value: {
            dataType: "string",
            format: { type: '', precision: 0 }
        }
    }, {
        text: "integer",
        value: {
            dataType: "number",
            format: { type: 'fixedpoint', precision: 0 }
        }
    }, {
        text: "percentage 2",
        value: {
            dataType: "number",
            format: { type: 'percent', precision: 2 }
        }
    }, {
        text: "percentage 5",
        value: {
            dataType: "number",
            format: { type: 'percent', precision: 5 }
        }
    }, {
        text: "decimal 2",
        value: {
            dataType: "number",
            format: { type: 'fixedpoint', precision: 2 }
        }
    }, {
        text: "decimal 5",
        value: {
            dataType: "number",
            format: { type: 'fixedpoint', precision: 5 }
        }
    }, {
        text: "boolean",
        value: {
            dataType: "boolean",
            format: { type: '', precision: 0 }
        }
    }];
});