"use strict";

(function () {
    window.dxGridExtensions = {
        isUndefinedOrNull: function isUndefinedOrNull(val) {
            return angular.isUndefined(val) || val === null;
        }
    };

    window.dxGridExtensions.groupCellTemplate = function (groupCell, info) {
        $('<div>').html(info.text).appendTo(groupCell);
    };

    window.dxGridExtensions.isInt = function (n) {
        return !isNaN(Number(n)) && Number(n) % 1 === 0;
    };

    window.dxGridExtensions.isFloat = function (n) {
        return !isNaN(Number(n)) && Number(n) % 1 !== 0;
    };

    window.dxGridExtensions.resetSelectBoxValue = function (selectBoxId) {

        var instance = $(selectBoxId).dxSelectBox("instance");
        if (dxGridExtensions.isUndefinedOrNull(instance)) return;
        instance.option("value", null);
    };

    window.dxGridExtensions.initFormulas = function (scope) {

        scope.AND = formulajs.AND;
        scope.OR = formulajs.OR;
        scope.NOT = formulajs.NOT;
        scope.IF = formulajs.IF;
        scope.ISNULL = formulajs.ISNULL;
        scope.CEILING = formulajs.CEILING;
        scope.EXP = formulajs.EXP;
        scope.FLOOR = formulajs.FLOOR;
        scope.MAX = formulajs.MAX;
        scope.MIN = formulajs.MIN;
        scope.POW = formulajs.POW;
        scope.RAND = formulajs.RAND;
        scope.RANDBETWEEN = formulajs.RANDBETWEEN;
        scope.ROUND = formulajs.ROUND;
        scope.SIGN = formulajs.SIGN;
        scope.DECIMAL = formulajs.DECIMAL;
        scope.INT = formulajs.INT;
        scope.CONCATENATE = formulajs.CONCATENATE;
        scope.CONTAINS = formulajs.CONTAINS;
        scope.LEN = formulajs.LEN;
        scope.LOWER = formulajs.LOWER;
        scope.MID = formulajs.MID;
        scope.TRIM = formulajs.TRIM;
        scope.UPPER = formulajs.UPPER;
        scope.TODAY = formulajs.TODAY;
        scope.WEEKDAY = formulajs.WEEKDAY;
        scope.MONTH = formulajs.MONTH;
        scope.YEAR = formulajs.YEAR;
    };

    //https://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-with-string-key
    Object.byString = function (o, s) {
        s = s.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
        s = s.replace(/^\./, ''); // strip a leading dot
        var a = s.split('.');
        for (var i = 0, n = a.length; i < n; ++i) {
            var k = a[i];
            if (k in o) {
                o = o[k];
            } else {
                return;
            }
        }
        return o;
    };

    // window.dxGridExtensions.createFlatGrid = function(flatgridConfig, dataSource) {
    //     flatgridConfig.bindingOptions.dataSource = 'widget.demoFlatData';
    //     flatgridConfig.bindingOptions['summary.groupItems'] = 'widget.config.flatGrid.groupItems';
    //     flatgridConfig.bindingOptions.columns = 'widget.config.flatGrid.columns';
    // };
})();

angular.module('dxGridExtensionTemplates', []);
var dxGridExtension = angular.module('dxGridExtension', ['dx', 'ngRoute', 'dxGridExtensionTemplates']);
"use strict";

dxGridExtension.controller('columnChooser', function columnChooserCrtl($scope, $controller, $timeout, customColumnConfiguration) {

    $scope.columnChooserGrid;
    $scope.self.gridManagement.showColumnChooserConsole = false;
    $scope.getAllColumns = getAllColumns;
    $scope.getColumnFormat = getColumnFormat;

    $scope.$watch(function () {
        return $scope.self.gridManagement.showColumnChooserConsole;
    }, function () {

        if (!$scope.self.gridManagement.showColumnChooserConsole) return;

        $timeout(function () {

            $scope.columnChooserDataSource.clear();

            var data = [];
            var columns = getAllColumns();

            var i = 0;

            _.forEach(columns, function (column) {
                $scope.columnChooserDataSource.insert(createColumnChooserColumnData(column, i++));
            });

            $scope.columnChooserGrid.dxDataGrid("instance").refresh();
        }, 500);
    });

    $scope.columnChooserPopupOptions = {
        width: 800,
        contentTemplate: "info",
        height: "100%",
        dragEnabled: true,
        showTitle: true,
        closeOnOutsideClick: false,
        title: "Management - Columns",
        bindingOptions: {
            visible: "gridManagement.showColumnChooserConsole"
        }
    };

    $scope.columnChooserDataSource = new DevExpress.data.ArrayStore({
        data: []
    });

    $scope.columnChooserGridOptions = {
        dataSource: {
            store: $scope.columnChooserDataSource,
            sort: 'position'
        },
        height: "90%",
        width: '100%',
        resize: false,
        onContentReady: function onContentReady(e) {
            initDragging(e.element);
        },
        onInitialized: function onInitialized(e) {
            $scope.columnChooserGrid = e.element;
        },
        allowColumnResizing: true,
        scrolling: {
            mode: "virtual"
        },
        filterRow: { visible: true },
        sorting: { mode: 'none' },
        hoverStateEnabled: true,
        controlColumnResizing: false,
        showRowLines: true,
        showColumnLines: true,
        selection: {
            mode: "single"
        },
        onRowValidating: function onRowValidating(e) {
            e.valid = true;
        },
        onRowPrepared: function onRowPrepared(e) {
            if (e.rowType != 'data') return;
            e.rowElement.addClass('dragRow');
            e.rowElement.data('keyValue', e.key);
        },
        editing: {
            mode: "popup",
            allowUpdating: true,
            popup: {
                showTitle: false,
                width: 700,
                height: 345,
                position: {
                    my: "middle",
                    at: "middle",
                    of: window
                }
            }
        },
        columns: [{
            dataField: 'caption',
            caption: "Caption"
        }, {
            dataField: "hasAggregation",
            caption: "Aggregation",
            dataType: "boolean",
            allowFiltering: false
        }, {
            dataField: "visible",
            caption: "Visible",
            dataType: "boolean",
            allowFiltering: true
        }, {
            dataField: "format",
            caption: "Format",
            lookup: {
                allowClearing: false,
                dataSource: customColumnConfiguration.customColumnFormats,
                displayExpr: "text",
                valueExpr: "text"
            },
            allowFiltering: false
        }, {
            dataField: 'position',
            caption: "Position",
            visible: false,
            allowFiltering: false
        }]
    };

    $scope.columnChooserValidateButtonOptions = {
        text: 'Validate changes',
        onClick: function onClick() {

            $scope.columnChooserGrid.dxDataGrid('instance').saveEditData().then(function (result) {
                $scope.updateGrid(function () {
                    _.forEach($scope.columnChooserDataSource._array, function (item) {

                        var column = _.find($scope.self.config.columns, function (col) {
                            return item.dataField === col.dataField;
                        });

                        column.visibleIndex = item.position;
                        column.caption = item.caption;
                        column.visible = item.visible;

                        if (item.hasAggregation) {
                            createAggregation(item.dataField);
                        } else {
                            removeAggregation(item.dataField);
                        }

                        var format = _.find(customColumnConfiguration.customColumnFormats, function (formatting) {
                            return formatting.text == item.format;
                        });

                        applyColumnFormating(column, format);
                    });

                    $timeout(function () {

                        $scope.gridInstance.option('columns', $scope.self.config.columns);
                        $scope.gridInstance.option('summary.groupItems', $scope.self.config.groupItems);
                    }, 500);
                });
                $scope.self.gridManagement.showColumnChooserConsole = false;
            });
        }
    };

    function getColumnFormat(column) {

        return _.find(customColumnConfiguration.customColumnFormats, function (item) {

            if (item.value.dataType == column.dataType) {

                if (dxGridExtensions.isUndefinedOrNull(item.value.format)) return false;

                if (item.value.format.type == column.format.type && item.value.format.precision == column.format.precision) return true;
            }

            return false;
        });
    };

    function getAllColumns() {

        var columnCount = $scope.gridInstance.columnCount();
        var columns = [];

        for (var i = 0; i < columnCount; i++) {
            columns.push($scope.gridInstance.columnOption(i));
        }return columns;
    };

    function initDragging($gridElement) {

        $gridElement.find('.dragRow').draggable({
            helper: 'clone',
            scroll: true,
            axis: "y",
            drag: function drag(event, ui) {

                $timeout(function () {

                    var scrollDownOffset = $scope.columnChooserGrid.height() + $scope.columnChooserGrid.offset().top - 50;
                    var scrollUpOffset = $scope.columnChooserGrid.offset().top + 50;

                    if (ui.offset.top < scrollUpOffset) {
                        var scrollable = $scope.columnChooserGrid.dxDataGrid("instance").getScrollable();
                        var offset = scrollable.scrollOffset().top - 10 < 0 ? 0 : scrollable.scrollOffset().top - 10;
                        console.log(offset);
                        scrollable.scrollTo(offset);
                    }

                    if (ui.offset.top > scrollDownOffset) {
                        var scrollable = $scope.columnChooserGrid.dxDataGrid("instance").getScrollable();
                        var offset = scrollable.scrollOffset().top + 10;
                        console.log(offset);
                        scrollable.scrollTo(offset);
                    };
                });
            },
            start: function start(event, ui) {

                var $originalRow = $(this);
                var $clonedRow = ui.helper;
                var $originalRowCells = $originalRow.children();
                var $clonedRowCells = $clonedRow.children();

                for (var i = 0; i < $originalRowCells.length; i++) {
                    $($clonedRowCells.get(i)).width($($originalRowCells.get(i)).width());
                }

                $clonedRow.width($originalRow.width());
                $clonedRow.addClass('drag-helper');
            }
        });

        $gridElement.find('.dragRow').droppable({
            drop: function drop(event, ui) {

                var draggingRowKey = ui.draggable.data('keyValue');
                var targetRowKey = $(this).data('keyValue');

                if (dxGridExtensions.isUndefinedOrNull(targetRowKey)) return;

                var draggingIndex = null;
                var targetIndex = null;
                $scope.columnChooserDataSource.byKey(draggingRowKey).done(function (item) {
                    draggingIndex = item.position;
                });
                $scope.columnChooserDataSource.byKey(targetRowKey).done(function (item) {
                    targetIndex = item.position;
                });
                var draggingDirection = targetIndex < draggingIndex ? 1 : -1;
                var dataItems = null;
                $scope.columnChooserDataSource.load().done(function (data) {
                    dataItems = data;
                });
                for (var dataIndex = 0; dataIndex < dataItems.length; dataIndex++) {
                    if (dataItems[dataIndex].position > Math.min(targetIndex, draggingIndex) && dataItems[dataIndex].position < Math.max(targetIndex, draggingIndex)) {
                        dataItems[dataIndex].position += draggingDirection;
                    }
                }

                $scope.columnChooserDataSource.update(draggingRowKey, { position: targetIndex });
                $scope.columnChooserDataSource.update(targetRowKey, { position: targetIndex + draggingDirection });

                $gridElement.dxDataGrid('instance').refresh();
            }
        });
    };

    function applyColumnFormating(column, format) {

        column.dataType = format.value.dataType;
        column.format = { type: null, precision: null };

        if (!dxGridExtensions.isUndefinedOrNull(format.value.format)) {
            column.format.type = format.value.format.type;
            column.format.precision = format.value.format.precision;
        }

        var groupItem = _.find($scope.self.config.groupItems, function (item) {
            return item.column === column.dataField;
        });

        if (!dxGridExtensions.isUndefinedOrNull(groupItem)) {

            if (dxGridExtensions.isUndefinedOrNull(format.value.format)) {
                groupItem.valueFormat.type = null;
                groupItem.valueFormat.precision = null;
            } else {
                groupItem.valueFormat.type = format.value.format.type;
                groupItem.valueFormat.precision = format.value.format.precision;
            }
        }
    };

    function removeAggregation(dataField) {

        _.remove($scope.self.config.groupItems, function (item) {
            return item.column === dataField;
        });
    };

    function createAggregation(dataField) {

        if (null == $scope.currentColumn || $scope.currentColumn.dataType == "string") return;

        var result = _.find($scope.self.config.groupItems, function (item) {
            return item.column === dataField;
        });

        if (!dxGridExtensions.isUndefinedOrNull(result)) return;

        var group = createDefaultNumberGroupItem(dataField);
        $scope.self.config.groupItems.push(group);
    };

    function createColumnChooserColumnData(column, id) {

        var format = getColumnFormat(column);

        return {
            Id: id,
            dataField: column.dataField,
            caption: column.caption + '',
            visible: column.visible,
            hasAggregation: !dxGridExtensions.isUndefinedOrNull(_.find($scope.self.config.groupItems, function (group) {
                return group.column == column.dataField;
            })),
            position: column.visibleIndex,
            format: format.text
        };
    };
});
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

dxGridExtension.controller('conditionalFormatting', function conditionalFormattingCrtl($scope, management, config, $controller, $timeout, conditionalFormattingConfiguration) {
    var _$scope$conditionalFo;

    var defaultColor = "#ff2600";
    var defaultIcon = conditionalFormattingConfiguration.availableIcons[0];

    $scope.management = management;

    $scope.management.showConditionalFormattingConsole = false;

    $scope.conditionalFormatingGrid = null;
    $scope.conditionalFormattingResult = [];
    $scope.conditionalFormatingExpressionText = '';
    $scope.isExpressionDisabled = true;
    $scope.isCreateRuleDisabled = true;
    $scope.conditionalFormattingExpressionTargetedColumns = [];
    $scope.selectedExistingConditionalFormattingRule = null;

    $scope.conditionalFormatingTargetColumn = null;
    $scope.selectedConditionalFormattingRule = null;
    $scope.selectedConditionalFormattingRules = [];
    $scope.currentConditionalFormattingColor = defaultColor;
    $scope.selectedConditionalFormattingIcon = defaultIcon;

    config.conditionalFormattingRules = !dxGridExtensions.isUndefinedOrNull(config.conditionalFormattingRules) ? _.transform(config.conditionalFormattingRules, function (result, item) {
        result.push(conditionalFormattingConfiguration.getRuleFromdescriptor(item));
    }, []) : [];

    $scope.$watch('selectedConditionalFormattingIcon', function () {

        if (!dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) {
            $scope.selectedConditionalFormattingRule.icon = $scope.selectedConditionalFormattingIcon;
            applyConditionalFormattingRule();
        }
    });

    $scope.$watch('currentConditionalFormattingColor', function () {

        if (dxGridExtensions.isUndefinedOrNull($scope.currentConditionalFormattingColor) || dxGridExtensions.isUndefinedOrNull($scope.conditionalFormatingGrid) || dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) return;

        var grid = $scope.conditionalFormatingGrid.dxDataGrid('instance');

        if (dxGridExtensions.isUndefinedOrNull(grid)) return;

        $scope.selectedConditionalFormattingRule.color = $scope.currentConditionalFormattingColor;

        applyConditionalFormattingRule();
    });

    $scope.$watch('selectedConditionalFormattingRule', function () {

        updateCreateRuleDisabled();

        if (dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) return;

        $scope.isExpressionDisabled = !$scope.selectedConditionalFormattingRule.isExpressionBased;

        applyConditionalFormattingRule();
    });

    $scope.$watch('conditionalFormatingExpressionText', function () {

        updateCreateRuleDisabled();

        if (dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) return;

        if ($scope.conditionalFormatingExpressionText === '') {
            $scope.conditionalFormattingResult = [];
        }
    });

    $scope.$watch('management.showConditionalFormattingConsole', function () {

        if (!dxGridExtensions.isUndefinedOrNull($scope.conditionalFormatingGrid)) {
            var conditionalFormattingGrid = $scope.conditionalFormatingGrid.dxDataGrid('instance');
            conditionalFormattingGrid.option('dataSource', null);
        };

        $scope.conditionalFormatingExpressionText = '';
        $scope.selectedConditionalFormattingIcon = defaultIcon;
        $scope.currentConditionalFormattingColor = defaultColor;
        $scope.conditionalFormatingTargetColumn = null;

        dxGridExtensions.resetSelectBoxValue("#conditionFormatingTargetColumn");
    });

    $scope.$watch('conditionalFormatingTargetColumn', function () {

        updateCreateRuleDisabled();

        if (dxGridExtensions.isUndefinedOrNull($scope.conditionalFormatingTargetColumn)) return;

        applyConditionalFormattingRule();
    });

    $scope.$watch('selectedConditionalFormattingRules', function () {

        if ($scope.selectedConditionalFormattingRules.length == 0) return;

        $scope.selectedConditionalFormattingRule = $scope.selectedConditionalFormattingRules[0].items[0];
    });

    $scope.$watch('selectedExistingConditionalFormattingRule', function () {
        $scope.isExistingRuleActionDisabled = dxGridExtensions.isUndefinedOrNull($scope.selectedExistingConditionalFormattingRule);
    });

    $scope.consitionalFormattingAvailableColumnsSelectBoxOptions = {
        bindingOptions: {
            items: "availableColumns",
            value: "selectedAvailableColumn",
            disabled: 'isExpressionDisabled'
        },
        onItemClick: function onItemClick(e) {
            $scope.conditionalFormatingExpressionText += '[' + e.itemData + ']';
            $scope.selectedAvailableColumn = null;
        },
        placeholder: "Add column to expression"
    };

    $scope.conditionalFormattingTestExpressionButtonOptions = {
        icon: 'fa fa-hacker-news',
        text: 'Test expression',
        bindingOptions: {
            disabled: 'isCreateRuleDisabled'
        },
        onClick: applyConditionalFormattingRule
    };

    $scope.conditionalFormattingPopupOptions = (_$scope$conditionalFo = {
        width: 750,
        contentTemplate: "info",
        showTitle: false,
        height: "auto"
    }, _defineProperty(_$scope$conditionalFo, 'showTitle', true), _defineProperty(_$scope$conditionalFo, 'title', "Management - Conditional Formatting"), _defineProperty(_$scope$conditionalFo, 'dragEnabled', true), _defineProperty(_$scope$conditionalFo, 'closeOnOutsideClick', true), _defineProperty(_$scope$conditionalFo, 'bindingOptions', {
        visible: "management.showConditionalFormattingConsole"
    }), _$scope$conditionalFo);

    $scope.conditionalFormatingExpressionTextBoxOptions = {
        bindingOptions: {
            value: "conditionalFormatingExpressionText",
            disabled: 'isExpressionDisabled'
        },
        placeholder: "Enter expression...",
        showClearButton: true
    };

    $scope.createConditionalFormattingButtonOptions = {
        icon: 'fa fa-hacker-news',
        text: 'Create expression',
        bindingOptions: {
            disabled: 'isCreateRuleDisabled'
        },
        onClick: function onClick(e) {

            if (dxGridExtensions.isUndefinedOrNull($scope.gridInstance)) return;

            var rule = conditionalFormattingConfiguration.createRule($scope.selectedConditionalFormattingRule.text, $scope.conditionalFormatingTargetColumn, $scope.conditionalFormatingExpressionText, $scope.currentConditionalFormattingColor, $scope.selectedConditionalFormattingIcon);

            _.remove(config.conditionalFormattingRules, { target: rule.target });

            config.conditionalFormattingRules.push(rule);

            $scope.gridInstance.repaint();

            $scope.managementshowConditionalFormattingConsole = false;
        }
    };

    $scope.conditionalFormatingAvailableTargetColumnsOptions = {
        bindingOptions: {
            value: "conditionalFormatingTargetColumn",
            items: "availableColumns"
        },
        placeholder: "Choose target column..."
    };

    $scope.conditionalFormattingResultGridPopupOptions = {
        bindingOptions: { dataSource: 'conditionalFormattingResult' },
        height: 350,
        resize: false,
        onInitialized: function onInitialized(e) {
            $scope.conditionalFormatingGrid = e.element;
        },
        allowColumnResizing: true,
        scrolling: {
            mode: "virtual"
        },
        loadPanel: {
            enabled: true
        },
        hoverStateEnabled: true,
        controlColumnResizing: true,
        showRowLines: true,
        showColumnLines: false,
        selection: {
            mode: "single"
        },
        sorting: {
            mode: "multiple"
        }
    };

    $scope.rulesListOptions = {
        bindingOptions: {
            selectedItems: 'selectedConditionalFormattingRules'
        },
        showSelectionControls: true,
        selectionMode: "single",
        selectAllMode: "allPages",
        items: conditionalFormattingConfiguration.availableRules,
        height: "50%",
        grouped: true,
        collapsibleGroups: true,
        groupTemplate: function groupTemplate(data) {
            return $("<div>Type: " + data.key + "</div>");
        }
    };

    $scope.conditionalFormattingColorBox = {
        bindingOptions: {
            value: "currentConditionalFormattingColor"
        },
        applyValueMode: "instantly"
    };

    $scope.availableIconsSelectBoxOptions = {
        dataSource: conditionalFormattingConfiguration.availableIcons,
        displayExpr: "name",
        valueExpr: "css",
        bindingOptions: {

            value: 'selectedConditionalFormattingIcon'
        },
        placeholder: 'Select an icon...'
    };

    $scope.deleteExistingRuleButtonOptions = {
        text: 'Delete',
        bindingOptions: {
            disabled: 'isExistingRuleActionDisabled'
        },
        onClick: function onClick() {

            _.remove(config.conditionalFormattingRules, { target: $scope.selectedExistingConditionalFormattingRule.target });

            $scope.gridInstance.repaint();

            $scope.managementshowConditionalFormattingConsole = false;
        }
    };

    $scope.loadExistingRuleButtonOptions = {
        text: 'Load',
        bindingOptions: {
            disabled: 'isExistingRuleActionDisabled'
        },
        onClick: function onClick() {

            $scope.conditionalFormatingTargetColumn = $scope.selectedExistingConditionalFormattingRule.target;
            $scope.conditionalFormatingExpressionText = $scope.selectedExistingConditionalFormattingRule.expression;
            $scope.currentConditionalFormattingColor = $scope.selectedExistingConditionalFormattingRule.color;
            $scope.selectedConditionalFormattingIcon = $scope.selectedExistingConditionalFormattingRule.icon;

            $("#conditionalFormattingRuleList").dxList("instance").selectItem(_.find(conditionalFormattingConfiguration.getAllRules(), function (rule) {
                return rule.text == $scope.selectedExistingConditionalFormattingRule.text;
            }));
        }
    };

    $scope.existingConditionalFormattingRulesSelectBoxOptions = {
        displayExpr: "target",
        bindingOptions: {
            dataSource: 'config.conditionalFormattingRules',
            value: 'selectedExistingConditionalFormattingRule'
        },
        placeholder: 'Load existing rule...'
    };

    function applyConditionalFormattingExpression() {

        try {
            $scope.conditionalFormattingResult = [];
            var expression = $scope.conditionalFormatingExpressionText;
            $scope.conditionalFormattingExpressionTargetedColumns = $scope.expression === '' ? [] : expression.match(/\[(.*?)\]/g);

            _.each($scope.dataSource, function (item) {

                var conditionalFormatingresult = {};

                _.each($scope.conditionalFormattingExpressionTargetedColumns, function (column) {

                    var sourceColumn = column.substring(1, column.length - 1);

                    if (!item.hasOwnProperty(sourceColumn)) throw new Error("Column " + sourceColumn + " does not exist");

                    conditionalFormatingresult[sourceColumn] = item[sourceColumn];
                });

                conditionalFormatingresult[$scope.conditionalFormatingTargetColumn] = item[$scope.conditionalFormatingTargetColumn];

                $scope.conditionalFormattingResult.push(conditionalFormatingresult);
            });
        } catch (e) {

            $scope.conditionalFormattingResult.push({
                error: e.message
            });

            return;
        }
    };

    function applyConditionalFormattingRule() {

        applyConditionalFormattingExpression();

        var grid = $scope.conditionalFormatingGrid.dxDataGrid('instance');

        if (dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) return;

        var rule = conditionalFormattingConfiguration.createRule($scope.selectedConditionalFormattingRule.text, $scope.conditionalFormatingTargetColumn, $scope.conditionalFormatingExpressionText, $scope.currentConditionalFormattingColor, $scope.selectedConditionalFormattingIcon);

        grid.option("onCellPrepared", function (options) {
            conditionalFormattingConfiguration.applyConditionalFormattingExpressionOnCell(options, rule, $scope.dataSource);
        });

        grid.repaint();
    };

    function updateCreateRuleDisabled() {

        if ($scope.conditionalFormatingTargetColumn == null || dxGridExtensions.isUndefinedOrNull($scope.selectedConditionalFormattingRule)) {
            $scope.isCreateRuleDisabled = true;
            return;
        }

        if ($scope.selectedConditionalFormattingRule.isExpressionBased && $scope.conditionalFormatingExpressionText === '') {
            $scope.isCreateRuleDisabled = true;
            return;
        }

        $scope.isCreateRuleDisabled = false;
    };
});
'use strict';

dxGridExtension.controller('customColumns', function customColumnsCrtl($scope, $controller, $timeout, $log, customColumnConfiguration) {

    $scope.self.gridManagement.showCustomColumnConsole = false;

    $scope.customColumnGrid = null;
    $scope.customColumnExpressionText = '';
    $scope.customColumnName = null;
    $scope.customColumnResult = [];
    $scope.customColumnSelectedAvailableColumn = null;
    $scope.selectedCustomColumnFormating = null;
    $scope.cannotCreateColumn = true;
    $scope.isExistingRuleActionDisabled = true;
    $scope.selectedExistingCustomColumn = null;
    $scope.isExistingCustomColumnActionDisabled = false;

    if (dxGridExtensions.isUndefinedOrNull($scope.self.config.customColumns)) $scope.self.config.customColumns = [];

    $scope.$watch(function () {
        return $scope.self.gridManagement.showCustomColumnConsole;
    }, function () {

        if (!$scope.self.gridManagement.showCustomColumnConsole) return;
        if (!dxGridExtensions.isUndefinedOrNull($scope.customColumnGrid)) $scope.customColumnGrid.dxDataGrid('instance').option('dataSource', null);
        $scope.customColumnExpressionText = '';
        $scope.customColumnName = '';
        $scope.customColumnSelectedAvailableColumn = null;

        dxGridExtensions.resetSelectBoxValue("#customColumnAvailableColumnsFormat");
        dxGridExtensions.resetSelectBoxValue("#existingCustomColumns");

        $scope.selectedExistingCustomColumn = '';
        $scope.selectedCustomColumnFormating = '';
    });

    $scope.$watch('customColumnExpressionText', function () {
        updateCanCreateColumn();
    });

    $scope.$watch('customColumnName', function () {
        updateCanCreateColumn();
    });

    $scope.$watch('selectedCustomColumnFormating', function () {
        updateCanCreateColumn();
    });

    $scope.$watch('selectedExistingCustomColumn', function () {
        $scope.isExistingCustomColumnActionDisabled = dxGridExtensions.isUndefinedOrNull($scope.selectedExistingCustomColumn) || $scope.selectedExistingCustomColumn == '';
    });

    $scope.customColumnResultGridOptions = {
        bindingOptions: { dataSource: 'customColumnResult' },
        height: 200,
        resize: false,
        onInitialized: function onInitialized(e) {
            $scope.customColumnGrid = e.element;
        },
        allowColumnResizing: true,
        scrolling: {
            mode: "virtual"
        },
        loadPanel: {
            enabled: true
        },
        hoverStateEnabled: true,
        controlColumnResizing: true,
        showRowLines: true,
        showColumnLines: false,
        selection: {
            mode: "single"
        },
        sorting: {
            mode: "multiple"
        }
    };

    $scope.customColumnAvailableColumnsSelectBoxOptions = {
        bindingOptions: {
            items: "availableColumns",
            value: "customColumnSelectedAvailableColumn"
        },
        onItemClick: function onItemClick(e) {
            $scope.customColumnExpressionText += '[' + e.itemData + ']';
            $scope.customColumnSelectedAvailableColumn = null;
            dxGridExtensions.resetSelectBoxValue("#customColumnAvailableColumns");
        },
        placeholder: "Add column to expression"
    };

    $scope.customColumnAvailableFormattingSelectBoxOptions = {
        displayExpr: "text",
        valueExpr: "value",
        items: customColumnConfiguration.customColumnFormats,
        bindingOptions: {
            value: "selectedCustomColumnFormating"
        },
        placeholder: "Choose column format"
    };

    $scope.customColumnPopupOptions = {
        width: 900,
        contentTemplate: "info",

        height: "auto",
        dragEnabled: true,
        showTitle: true,
        title: "Management - Custom Columns",
        closeOnOutsideClick: true,
        bindingOptions: {
            visible: "gridManagement.showCustomColumnConsole"
        }
    };

    $scope.customColumnNameTextBoxOptions = {
        bindingOptions: {
            value: "customColumnName"
        },
        placeholder: "Enter column name...",
        showClearButton: true
    };

    $scope.customColumnExpressionTextBoxOptions = {
        bindingOptions: {
            value: "customColumnExpressionText"
        },
        placeholder: "Enter expression...",
        showClearButton: true
    };

    $scope.customColumnTestExpressionButtonOptions = {
        icon: 'fa fa-hacker-news',
        text: 'Test expression',
        bindingOptions: {
            disabled: 'cannotCreateColumn'
        },
        onClick: applyCustomColumnExpression
    };

    $scope.createRuleButtonOptions = {
        icon: 'fa fa-hacker-news',
        text: 'Create column',
        bindingOptions: {
            disabled: 'cannotCreateColumn'
        },

        onClick: function onClick(e) {

            if (dxGridExtensions.isUndefinedOrNull($scope.gridInstance)) return;

            $scope.updateGrid(function () {

                var rule = customColumnConfiguration.createCustomColumn($scope.customColumnName, $scope.customColumnExpressionText, $scope.selectedCustomColumnFormating);

                var doesColumnExist = _.remove($scope.self.config.customColumns, { name: rule.name }).length > 0;

                if (doesColumnExist) {
                    removeCustomColumn(rule.name);
                }

                $scope.self.config.customColumns.push(rule);

                customColumnConfiguration.computeCustomColumn(rule, $scope.dataSource);

                var column = {
                    dataField: $scope.customColumnName,
                    caption: $scope.customColumnName,
                    dataType: $scope.selectedCustomColumnFormating.dataType,
                    format: { type: $scope.selectedCustomColumnFormating.format.type, precision: $scope.selectedCustomColumnFormating.format.precision },
                    visibleIndex: $scope.currentColumn.visibleIndex
                };

                $scope.self.config.columns.push(column);

                if ($scope.selectedCustomColumnFormating.dataType === 'number' && $scope.self.config.groupItems) {

                    $scope.self.config.groupItems.push({
                        column: column.dataField,
                        summaryType: "sum",
                        showInGroupFooter: false,
                        alignByColumn: true,
                        valueFormat: {
                            type: $scope.selectedCustomColumnFormating.format.type,
                            precision: $scope.selectedCustomColumnFormating.format.precision
                        },
                        displayFormat: "{0}"
                    });
                }
            });

            var state = $scope.gridInstance.state ? $scope.gridInstance.state() : undefined;
            if (state) $scope.gridInstance.state(state);

            $scope.self.gridManagement.showCustomColumnConsole = false;
        }
    };

    $scope.deleteExistingCustomColumnButtonOptions = {
        text: 'Delete',
        bindingOptions: {
            disabled: 'isExistingCustomColumnActionDisabled'
        },
        onClick: function onClick() {
            removeCustomColumn($scope.selectedExistingCustomColumn.name);
            $scope.self.gridManagement.showCustomColumnConsole = false;
        }
    };

    $scope.loadExistingCustomColumnButtonOptions = {
        text: 'Load',
        bindingOptions: {
            disabled: 'isExistingCustomColumnActionDisabled'
        },
        onClick: function onClick() {
            $scope.customColumnName = $scope.selectedExistingCustomColumn.name;
            $scope.customColumnExpressionText = $scope.selectedExistingCustomColumn.expression;
            $scope.selectedCustomColumnFormating = $scope.selectedExistingCustomColumn.format;
        }
    };

    $scope.existingCustomColumnsSelectBoxOptions = {
        displayExpr: "name",
        bindingOptions: {
            dataSource: 'config.customColumns',
            value: 'selectedExistingCustomColumn'
        },
        placeholder: 'Load existing column...'
    };

    function removeCustomColumn(name) {

        _.remove($scope.self.config.customColumns, { name: name });

        _.each($scope.dataSource, function (item) {
            delete item[name];
        });

        _.remove($scope.self.config.columns, { dataField: name });
        _.remove($scope.self.config.groupItems, { column: name });

        $scope.gridInstance.repaint();
    };

    function updateCanCreateColumn() {
        $scope.cannotCreateColumn = $scope.selectedCustomColumnFormating == '' || $scope.customColumnExpressionText == '' || dxGridExtensions.isUndefinedOrNull($scope.customColumnName) || dxGridExtensions.isUndefinedOrNull($scope.selectedCustomColumnFormating);
    };

    function applyCustomColumnExpression() {

        try {

            if (_.some($scope.self.config.columns, function (column) {
                return column.caption === $scope.customColumnName;
            })) throw new Error("Column " + $scope.customColumnName + " already exist");
            if (_.some($scope.self.config.customColumns, function (column) {
                return column.caption === $scope.customColumnName;
            })) throw new Error("Column " + $scope.customColumnName + " already exist");

            var expression = $scope.customColumnExpressionText;
            var customColumnExpressionTargetedColumns = expression.match(/\[(.*?)\]/g);

            $scope.customColumnResult = [];

            _.each($scope.dataSource, function (item) {

                var customColumnResult = {};

                _.each(customColumnExpressionTargetedColumns, function (column) {

                    var sourceColumn = column.substring(1, column.length - 1);

                    if (!item.hasOwnProperty(sourceColumn)) throw new Error("Column " + sourceColumn + " does not exist");

                    customColumnResult[sourceColumn] = item[sourceColumn];
                });

                customColumnResult[$scope.customColumnName] = item[$scope.customColumnName];

                $scope.customColumnResult.push(customColumnResult);
            });

            var grid = $scope.customColumnGrid.dxDataGrid('instance');

            customColumnConfiguration.computeCustomColumn({
                name: $scope.customColumnName,
                expression: expression
            }, $scope.customColumnResult);

            //refacto
            $timeout(function () {
                grid.columnOption($scope.customColumnName, 'dataType', $scope.selectedCustomColumnFormating.dataType);

                if ($scope.selectedCustomColumnFormating.format != null) {

                    grid.columnOption($scope.customColumnName, 'format', {
                        type: $scope.selectedCustomColumnFormating.format.type,
                        precision: $scope.selectedCustomColumnFormating.format.precision
                    });
                }
            }, 500);
        } catch (e) {

            $scope.customColumnResult.push({
                error: e.message
            });

            return;
        }
    };
});
"use strict";

dxGridExtension.controller('columnManagement', function columnManagementCrtl($scope, $controller, $timeout, customColumnConfiguration) {

    $scope.self.gridManagement.showColumnManagementConsole = false;

    $scope.columnManagementColumnName;
    $scope.columnManagementColumnFormating;
    $scope.cannotValidateChange;

    $scope.columnManagementPopupOptions = {
        width: 350,
        contentTemplate: "info",
        height: "auto",
        dragEnabled: true,
        showTitle: true,
        closeOnOutsideClick: true,
        bindingOptions: {
            visible: "gridManagement.showColumnManagementConsole",
            title: "columnManagementColumnName"
        }
    };

    $scope.$watch(function () {
        return $scope.self.gridManagement.showColumnManagementConsole;
    }, function () {

        if (dxGridExtensions.isUndefinedOrNull($scope.currentColumn) || !$scope.self.gridManagement.showColumnManagementConsole) return;

        $scope.columnManagementColumnName = $scope.currentColumn.caption;

        $scope.columnManagementColumnFormating = _.find(customColumnConfiguration.customColumnFormats, function (item) {

            if (item.value.dataType == $scope.currentColumn.dataType) {

                if (!dxGridExtensions.isUndefinedOrNull($scope.currentColumn.format)) {

                    if (dxGridExtensions.isUndefinedOrNull(item.value.format)) return false;

                    if (item.value.format.type == $scope.currentColumn.format.type && item.value.format.precision == $scope.currentColumn.format.precision) return true;
                } else {
                    if (dxGridExtensions.isUndefinedOrNull(item.value.format)) return true;
                }
            }

            return false;
        });
    });

    $scope.$watch('columnManagementColumnName', function () {
        $scope.cannotValidateChange = $scope.columnManagementColumnName == '';
    });

    $scope.columnManagementColumnNameTextBoxOptions = {
        bindingOptions: {
            value: "columnManagementColumnName"
        },
        onInput: function onInput(e) {
            $scope.cannotValidateChange = e.component._options.text == '';
        },
        showClearButton: true
    };

    $scope.columnManagementAvailableFormattingSelectBoxOptions = {
        displayExpr: "text",
        items: customColumnConfiguration.customColumnFormats,
        bindingOptions: {
            value: "columnManagementColumnFormating"
        }
    };

    $scope.columnManagementValidateButtonOptions = {
        text: 'Validate changes',
        bindingOptions: {
            disabled: 'cannotValidateChange'
        },
        onClick: function onClick() {

            $scope.updateGrid(function () {

                $scope.gridInstance.columnOption($scope.currentColumn.dataField, 'caption', $scope.columnManagementColumnName);
                $scope.gridInstance.columnOption($scope.currentColumn.dataField, 'dataType', $scope.columnManagementColumnFormating.value.dataType);
                $scope.gridInstance.columnOption($scope.currentColumn.dataField, 'format', { type: null, precision: null });

                if (!dxGridExtensions.isUndefinedOrNull($scope.columnManagementColumnFormating.value.format)) {
                    $scope.gridInstance.columnOption($scope.currentColumn.dataField, 'format.type', $scope.columnManagementColumnFormating.value.format.type);
                    $scope.gridInstance.columnOption($scope.currentColumn.dataField, 'format.precision', $scope.columnManagementColumnFormating.value.format.precision);
                }

                var groupItem = _.find($scope.groupItems, function (item) {
                    return item.column === $scope.currentColumn.dataField;
                });

                if (!dxGridExtensions.isUndefinedOrNull(groupItem)) {

                    if (dxGridExtensions.isUndefinedOrNull($scope.columnManagementColumnFormating.value.format)) {
                        groupItem.valueFormat.type = null;
                        groupItem.valueFormat.precision = null;
                    } else {
                        groupItem.valueFormat.type = $scope.columnManagementColumnFormating.value.format.type;
                        groupItem.valueFormat.precision = $scope.columnManagementColumnFormating.value.format.precision;
                    }
                }

                //bindings do not work...
                $scope.gridInstance.option($scope.currentColumn.dataField, 'summary.groupItems', $scope.self.config.groupItems);
            });

            $scope.self.gridManagement.showColumnManagementConsole = false;
        }
    };
});
'use strict';

dxGridExtension.controller('baseGridManagement', function baseGridManagementCrtl($scope, $controller, $attrs) {

    $scope.self = $scope.$parent;
    $scope.gridName = $attrs.instance;
    if (!$scope.self.gridManagement) $scope.self.gridManagement = {};

    if (!$scope.self.config) {
        $scope.self.config = {};
        $scope.self.config[$attrs.instance] = {};
    }

    $scope.self.gridManagement[$attrs.instance];
    $scope.self.config[$attrs.instance];

    $scope.updateGrid = function (action) {

        $scope.gridInstance.beginUpdate();
        action();
        $scope.gridInstance.endUpdate();
    };

    function updateAvailableColumns() {

        if (dxGridExtensions.isUndefinedOrNull($scope.self.config.columns)) return;
        $scope.dataSource = $scope.self[$attrs.datasource];
        $scope.availableColumns = _.sortBy(_.transform($scope.self.config.columns.concat(null === $scope.self.config.customColumns ? [] : $scope.self.config.customColumns), function (result, item) {
            result.push(item.dataField);
        }, []), function (e) {
            return e;
        });
    };

    $scope.$watch(function () {
        return $scope.self[$attrs.datasource];
    }, function () {

        $scope.dataSource = $scope.self[$attrs.datasource];
        updateAvailableColumns();

        $scope.availableColumns = _.sortBy(_.transform($scope.self.config.columns, function (result, item) {
            result.push(item.dataField);
        }, []), function (e) {
            return e;
        });
    });

    $scope.$watch(function () {
        return $scope.self.config.customColumns;
    }, function () {

        updateAvailableColumns();
    });

    $scope.$watch(function () {
        return $scope.self.config.customColumns.length;
    }, function () {

        updateAvailableColumns();
    });

    $scope.$watch(function () {
        return $scope.self[$attrs.instance];
    }, function () {

        $scope.gridInstance = $scope.self[$attrs.instance];
    });

    $scope.$watch(function () {
        return $scope.self.gridManagement[$attrs.instance].currentColumn;
    }, function () {

        $scope.currentColumn = $scope.self.gridManagement[$attrs.instance].currentColumn;
    });

    $scope.$watch(function () {
        return $scope.self.gridManagement[$attrs.instance].currentRow;
    }, function () {

        $scope.currentRow = $scope.self.gridManagement[$attrs.instance].currentRow;
    });

    var args = { $scope: $scope, management: $scope.self.gridManagement[$attrs.instance], config: $scope.self.config[$attrs.instance] };

    $controller('columnManagement', args);
    $controller('conditionalFormatting', args);
    $controller('columnChooser', args);
    $controller('customColumns', args);
});
'use strict';

dxGridExtension.directive('flatGridManagement', function ($controller) {
    return {
        restrict: "E",
        scope: true,
        templateUrl: 'view.flat.grid.management.html',
        controller: function controller($scope, $attrs) {
            $controller('baseGridManagement', { $scope: $scope, $attrs: $attrs });
        }
    };
});
'use strict';

dxGridExtension.directive('flatGrid', function ($timeout, customColumnConfiguration, conditionalFormattingConfiguration) {
    return {
        restrict: "E",
        templateUrl: 'view.grid.flat.html',
        scope: true,
        controller: function controller($scope, $attrs, $element, $controller) {

            $scope.self = $scope.$parent;

            //refacto: implement inheritance
            if (!$scope.self.config) $scope.self.config = {};
            $scope.self.config[$attrs.instance] = {};

            $scope.flatGridName = $attrs.instance;
            $scope.flatGridOptions = $scope.self[$attrs.options];
            $scope.$control = $element;

            if (!$scope.self.gridManagement) $scope.self.gridManagement = {};
            $scope.self.gridManagement[$scope.flatGridName] = {};

            var columns = dxGridExtensions.isUndefinedOrNull(getConfig('columns')) ? null : getConfig('columns');
            var groupItems = dxGridExtensions.isUndefinedOrNull(getConfig('groupItems')) ? null : getConfig('groupItems');

            setConfig('columns', columns);
            setConfig('groupItems', groupItems);

            $timeout(function () {
                return initializeInternal();
            });

            $scope.$watch($scope.flatGridOptions.bindingOptions.columns, function () {

                var columns = getConfig('columns');
                var groupItems = getConfig('groupItems');

                var groups = _.transform(columns, function (aggregate, item) {

                    if (item.dataType === "number") {

                        var existingGroup = _.find(groupItems, function (group) {
                            return item.column == item.dataField;
                        });

                        if (!dxGridExtensions.isUndefinedOrNull(existingGroup)) {
                            aggregate.push(groupItem);
                        } else {

                            var groupItem = createDefaultNumberGroupItem(item.dataField);
                            aggregate.push(groupItem);
                        }
                    }
                }, []);

                setConfig('groupItems', groups);
            });

            $scope.$watch($scope.flatGridOptions.bindingOptions.dataSource, function () {

                var dataSource = getDataSource();

                if (dxGridExtensions.isUndefinedOrNull(dataSource) || dataSource.length == 0) return;

                _.each(getConfig('customColumns'), function (rule) {
                    customColumnConfiguration.computeCustomColumn(rule, dataSource);
                });

                var template = dataSource[0];

                var index = 0;

                var columns = _.transform(Object.keys(template), function (aggregate, field) {

                    var columnOption = {
                        dataField: field,
                        caption: field,
                        dataType: "string",
                        visibleIndex: index++,
                        format: { type: '', precision: 0 }
                    };

                    var existingColumn = _.find(getConfig('columns'), function (c) {
                        return c.dataField == field;
                    });

                    if (null != existingColumn) {

                        aggregate.push(existingColumn);
                    } else {

                        for (var i = 0; i < dataSource.length; i++) {

                            if (!dxGridExtensions.isUndefinedOrNull(dataSource[i][field])) {

                                if (typeof dataSource[i][field] === "boolean") {

                                    columnOption.dataType = "boolean";

                                    break;
                                }

                                if (dxGridExtensions.isInt(dataSource[i][field])) {

                                    columnOption.dataType = "number";
                                    columnOption.format = { type: 'fixedpoint', precision: 0 };
                                    break;
                                }

                                if (dxGridExtensions.isFloat(dataSource[i][field])) {

                                    columnOption.dataType = "number";
                                    columnOption.summaryType = "sum";
                                    columnOption.format = { type: 'fixedpoint', precision: 2 };
                                    break;
                                }

                                columnOption.dataType = "string";
                                columnOption.format = { type: '', precision: 0 };

                                break;
                            }
                        };

                        aggregate.push(columnOption);
                    }
                }, []);

                setConfig('columns', columns);
            });

            function getDataSource() {
                return Object.byString($scope, $scope.flatGridOptions.bindingOptions.dataSource.dataPath);
            };

            function getGridInstance() {
                if (dxGridExtensions.isUndefinedOrNull($scope.$control)) return null;
                try {
                    //if the grid has been rendered
                    var grid = $scope.self[$scope.flatGridName].NAME ? $scope.self[$scope.flatGridName] : $scope.$control.find('#flatGrid').dxDataGrid("instance");
                    if ($scope.self[$scope.flatGridName] !== grid) $scope.self[$scope.flatGridName] = grid;
                    return grid;
                } catch (ex) {
                    return null;
                }
            };

            function setConfig(index, value) {
                if (dxGridExtensions.isUndefinedOrNull($scope.self.config[$scope.flatGridName])) $scope.self.config[$scope.flatGridName] = {};
                $scope.self.config[$scope.flatGridName][index] = value;
            };

            function getConfig(index) {
                if (dxGridExtensions.isUndefinedOrNull($scope.self.config[$scope.flatGridName])) $scope.self.config[$scope.flatGridName] = {};
                return $scope.self.config[$scope.flatGridName][index];
            };

            function initializeInternal() {

                $timeout(function () {

                    var grid = getGridInstance();

                    if (dxGridExtensions.isUndefinedOrNull(grid.option("onCellPrepared"))) {
                        addEventHandler("onCellPrepared", function (options) {
                            _.each(getConfig('conditionalFormattingRules'), function (rule) {
                                conditionalFormattingConfiguration.applyConditionalFormattingExpressionOnCell(options, rule, getDataSource());
                            });
                        });
                    }

                    addEventHandler("onContextMenuPreparing", function (options) {
                        if (options.row && options.row.rowType === 'data') {
                            options.items = getGridMenuItems(options);
                        }
                    });

                    addEventHandler("customizeColumns", function (columns) {
                        _.each(columns, function (column) {
                            column.groupCellTemplate = window.dxGridExtensions.groupCellTemplate;
                        });
                    });

                    var state = getConfig('gridState');

                    if (!dxGridExtensions.isUndefinedOrNull(state)) {
                        var grid = getGridInstance();
                        grid.state(state);
                    }
                });
            };

            function addEventHandler(ev, handler) {

                var grid = getGridInstance();
                var current = grid.option(ev);

                grid.option(ev, function (options) {
                    if (null != current) current(options);
                    handler(options);
                });
            };

            function getGridMenuItems(element) {

                $scope.self.gridManagement[$scope.flatGridName].currentColumn = element.column;
                $scope.self.gridManagement[$scope.flatGridName].currentRow = element.row;

                return [{
                    text: 'Management - Columns',
                    onItemClick: function onItemClick() {
                        $scope.self.gridManagement[$scope.flatGridName].showColumnChooserConsole = true;
                    }
                }, {
                    text: 'Management - Conditional Formatting',
                    onItemClick: function onItemClick() {
                        $scope.self.gridManagement[$scope.flatGridName].showConditionalFormattingConsole = true;
                    }
                }, {
                    text: 'Management - Custom Columns',
                    onItemClick: function onItemClick() {
                        $scope.self.gridManagement[$scope.flatGridName].showCustomColumnConsole = true;
                    }
                }, {
                    text: 'Current Column - Modify',
                    onItemClick: function onItemClick() {
                        $scope.self.gridManagement[$scope.flatGridName].showColumnManagementConsole = true;
                    }
                }, {
                    text: 'Current Column - Remove Aggregation',
                    onItemClick: function onItemClick() {
                        _.remove($scope.self.config[$scope.flatGridName].groupItems, function (item) {
                            return item.column === $scope.self.gridManagement[$scope.flatGridName].currentColumn.dataField;
                        });
                    }
                }, {
                    text: 'Current Column - Create Aggregation',
                    onItemClick: function onItemClick() {

                        if (null == $scope.self.gridManagement[$scope.flatGridName].currentColumn || $scope.self.gridManagement[$scope.flatGridName].currentColumn.dataType == "string") return;

                        var groupItems = getConfig('groupItems');
                        if (dxGridExtensions.isUndefinedOrNull(groupItems)) return;

                        var result = _.find($scope.self.config.groupItems, function (item) {
                            return item.column === $scope.self.gridManagement[$scope.flatGridName].currentColumn.dataField;
                        });

                        if (!dxGridExtensions.isUndefinedOrNull(result)) return;

                        var group = createDefaultNumberGroupItem($scope.self.gridManagement[$scope.flatGridName].currentColumn.dataField);
                        $scope.self.config[$scope.flatGridName].groupItems.push(group);
                    }
                }];
            };

            function createDefaultNumberGroupItem(name) {
                return {
                    column: name,
                    summaryType: "sum",
                    showInGroupFooter: false,
                    alignByColumn: true,
                    valueFormat: { type: 'fixedpoint', precision: 2 },
                    displayFormat: "{0}"
                };
            };

            $scope.self.exportExcel = function () {

                var grid = getGridInstance();
                grid.option("export", {
                    enabled: false,
                    fileName: $scope.self.container._config.title + "_" + moment($scope.self.workspace.date).format('YYYYMMDD')
                });

                grid.exportToExcel();
            };

            $controller('baseGridManagement', { $scope: $scope, $attrs: $attrs });
        }

    };
});
'use strict';

dxGridExtension.directive('treeGridManagement', function ($controller) {
    return {
        restrict: "E",
        scope: {},
        templateUrl: 'view.tree.grid.management.html',
        controller: function controller($scope, $attrs) {

            $controller('baseGridManagement', { $scope: $scope, $attrs: $attrs });
        }
    };
});
'use strict';

dxGridExtension.directive('treeGrid', function ($timeout, $controller, customColumnConfiguration, conditionalFormattingConfiguration) {
    return {
        restrict: "E",
        templateUrl: 'view.grid.tree.html',
        scope: true,
        link: {
            pre: function pre(scope, element, attrs) {

                scope.self = scope.$parent;

                //refacto: implement inheritance
                if (!scope.self.config) scope.self.config = {};
                scope.self.config[attrs.instance] = {};

                scope.treeListName = attrs.instance;
                scope.treeListOptions = scope.self[attrs.options];
                scope.$control = element;

                if (!scope.self.gridManagement) scope.self.gridManagement = {};
                scope.self.gridManagement[scope.treeListName] = {};

                var columns = dxGridExtensions.isUndefinedOrNull(getConfig('columns')) ? null : getConfig('columns');

                setConfig('columns', columns);

                $timeout(function () {
                    return initializeInternal();
                });

                scope.$watch(scope.treeListOptions.bindingOptions.dataSource, function () {

                    var dataSource = Object.byString(scope, scope.treeListOptions.bindingOptions.dataSource.dataPath);

                    if (dxGridExtensions.isUndefinedOrNull(dataSource) || dataSource.length == 0) return;

                    var template = dataSource[0];

                    var index = 0;

                    var columns = _.transform(Object.keys(template), function (aggregate, field) {

                        var columnOption = {
                            dataField: field,
                            caption: field,
                            dataType: "string",
                            format: { type: '', precision: 0 },
                            visibleIndex: index++
                        };

                        var existingColumn = _.find(getConfig('columns'), function (c) {
                            return c.dataField == field;
                        });

                        if (null != existingColumn) {

                            aggregate.push(existingColumn);
                        } else {

                            for (var i = 0; i < dataSource.length; i++) {

                                if (!dxGridExtensions.isUndefinedOrNull(dataSource[i][field])) {

                                    if (typeof dataSource[i][field] === "boolean") {

                                        columnOption.dataType = "boolean";

                                        break;
                                    }

                                    if (window.dxGridExtensions.isInt(dataSource[i][field])) {

                                        columnOption.dataType = "number";
                                        columnOption.format = { type: 'fixedpoint', precision: 0 };
                                        break;
                                    }

                                    if (window.dxGridExtensions.isFloat(dataSource[i][field])) {

                                        columnOption.dataType = "number";
                                        columnOption.summaryType = "sum";
                                        columnOption.format = { type: 'fixedpoint', precision: 2 };
                                        break;
                                    }

                                    columnOption.dataType = "string";
                                    columnOption.format = { type: '', precision: 0 };

                                    break;
                                }
                            };

                            aggregate.push(columnOption);
                        }
                    }, []);

                    setConfig('columns', columns);
                });

                function getDataSource() {
                    return Object.byString(scope, scope.treeListOptions.bindingOptions.dataSource.dataPath);
                };

                function getGridInstance() {
                    if (dxGridExtensions.isUndefinedOrNull(scope.$control)) return null;
                    try {
                        //if the grid has been rendered
                        var grid = scope.self[scope.treeListName].NAME ? scope.self[scope.treeListName] : scope.$control.find('#treeGrid').dxTreeList("instance");
                        if (scope.self[scope.treeListName] !== grid) scope.self[scope.treeListName] = grid;
                        return grid;
                    } catch (ex) {
                        return null;
                    }
                };

                function setConfig(index, value) {
                    if (dxGridExtensions.isUndefinedOrNull(scope.self.config[scope.treeListName])) scope.self.config[scope.treeListName] = {};
                    scope.self.config[scope.treeListName][index] = value;
                };

                function getConfig(index) {
                    if (dxGridExtensions.isUndefinedOrNull(scope.self.config[scope.treeListName])) scope.self.config[scope.treeListName] = {};
                    return scope.self.config[scope.treeListName][index];
                };

                function initializeInternal() {

                    $timeout(function () {

                        var grid = getGridInstance();

                        //fixed conditional formatting
                        if (dxGridExtensions.isUndefinedOrNull(grid.option("onCellPrepared"))) {
                            addEventHandler("onCellPrepared", function (options) {
                                _.each(getConfig('conditionalFormattingRules'), function (rule) {

                                    var dataSource = Object.byString(scope, scope.treeListOptions.bindingOptions.dataSource.dataPath);

                                    conditionalFormattingConfiguration.applyConditionalFormattingExpressionOnCell(options, rule, dataSource);
                                });
                            });
                        }

                        //init context menu
                        addEventHandler("onContextMenuPreparing", function (options) {
                            if (options.row && options.row.rowType === 'data') {
                                options.items = getGridMenuItems(options);
                            }
                        });;

                        addEventHandler("customizeColumns", function (columns) {
                            _.each(columns, function (column) {
                                column.groupCellTemplate = window.dxGridExtensions.groupCellTemplate;
                            });
                        });
                    });
                };

                function addEventHandler(ev, handler) {

                    var grid = getGridInstance();

                    var current = grid.option(ev);

                    grid.option(ev, function (options) {
                        if (null != current) current(options);
                        handler(options);
                    });
                };

                function getGridMenuItems(element) {

                    scope.self.gridManagement[scope.treeListName].currentColumn = element.column;
                    scope.self.gridManagement[scope.treeListName].currentRow = element.row;

                    return [{
                        text: 'Management - Columns',
                        onItemClick: function onItemClick() {
                            scope.self.gridManagement[scope.treeListName].showColumnChooserConsole = true;
                        }
                    }, {
                        text: 'Management - Conditional Formatting',
                        onItemClick: function onItemClick() {
                            scope.self.gridManagement[scope.treeListName].showConditionalFormattingConsole = true;
                        }
                    }, {
                        text: 'Management - Custom Columns',
                        onItemClick: function onItemClick() {
                            scope.self.gridManagement[scope.treeListName].showCustomColumnConsole = true;
                        }
                    }, {
                        text: 'Current Column - Modify',
                        onItemClick: function onItemClick() {

                            scope.self.gridManagement[scope.treeListName].showColumnManagementConsole = true;
                        }
                    }];
                };
            }

        }

    };
});
'use strict';

angular.module('dxGridExtensionTemplates').run(['$templateCache', function ($templateCache) {
  $templateCache.put('view.flat.grid.management.html', '<div class="popup" id="conditionalFormattingConsole" dx-popup="conditionalFormattingPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div style="margin:5px;min-height:30px">\r\n            <div class="dx-fieldset">\r\n                <div class="dx-fieldset-header">Select an existing rule..</div>\r\n                <div class="dx-field">\r\n                    <div class="field-container">\r\n                        <div style="float:left;width:50%;" id="existingConditionalFormattingRules" dx-select-box="existingConditionalFormattingRulesSelectBoxOptions"></div>\r\n                        <div style="float:right;width:20%;" dx-button="deleteExistingRuleButtonOptions"></div>\r\n                        <div style="float:right;width:20%;" dx-button="loadExistingRuleButtonOptions"></div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class="dx-fieldset">\r\n                <div class="dx-fieldset-header">...or create a new one</div>\r\n                <div class="dx-field">\r\n                    <div class="field-container">\r\n                        <div style="float:left;width:49%;margin-right:5px;" id="conditionFormatingTargetColumn" dx-select-box="conditionalFormatingAvailableTargetColumnsOptions"></div>\r\n                        <div style="float:right;width:50%;" dx-select-box="consitionalFormattingAvailableColumnsSelectBoxOptions"></div>\r\n                    </div>\r\n                    <div style="float:left;width:100%;margin-top:5px;" dx-text-box="conditionalFormatingExpressionTextBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="field-container">\r\n                <div style="margin:5px;float:left;width:65%;">\r\n                    <div style="top:50px;margin:5px;width:100%;" id="ruleTestingGrid" dx-data-grid="conditionalFormattingResultGridPopupOptions"></div>\r\n                </div>\r\n                <div style="margin:5px;float:right;width:30%;">\r\n                    <div id="conditionalFormattingRuleList" dx-list="rulesListOptions"></div>\r\n                    <div style="margin-top:10px;" dx-color-box="conditionalFormattingColorBox"></div>\r\n                    <div style="margin-top:10px;" dx-select-box="availableIconsSelectBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="field-container">\r\n                <div style="float:left;width:48%;margin-bottom:20px;" dx-button="conditionalFormattingTestExpressionButtonOptions"></div>\r\n                <div style="float:right;width:48%;margin-bottom:20px;" dx-button="createConditionalFormattingButtonOptions"></div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="customColumnConsole" dx-popup="customColumnPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div class="dx-fieldset">\r\n            <div class="dx-fieldset-header">Select an existing custom column...</div>\r\n            <div class="dx-field">\r\n                <div style="width:100%;min-height:30px;">\r\n                    <div style="float:left;width:40%;" id="existingCustomColumns" dx-select-box="existingCustomColumnsSelectBoxOptions"></div>\r\n                    <div style="float:right;width:28%;margin:0px;" dx-button="deleteExistingCustomColumnButtonOptions"></div>\r\n                    <div style="float:right;width:27%;margin:0px 5px 0px 0px;" dx-button="loadExistingCustomColumnButtonOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class="dx-fieldset">\r\n            <div class="dx-fieldset-header">...or create a new one</div>\r\n            <div class="dx-field">\r\n                <div style="width:100%;min-height:30px;">\r\n                    <div style="float:left;width:25%;margin-right:5px;" id="customColumnColumnName" dx-text-box="customColumnNameTextBoxOptions"></div>\r\n                    <div style="float:left;width:35%;" id="customColumnAvailableColumnsFormat" dx-select-box="customColumnAvailableFormattingSelectBoxOptions"></div>\r\n                    <div style="float:right;width:35%;" id="customColumnAvailableColumns" dx-select-box="customColumnAvailableColumnsSelectBoxOptions"></div>\r\n                </div>\r\n                <div style="width:100%;" dx-text-box="customColumnExpressionTextBoxOptions"></div>\r\n                <div style="width:100%;margin-top:5px;min-height:30px;">\r\n                    <div style="float:left;width:50%;margin:0px 5px 0px 0px;" dx-button="customColumnTestExpressionButtonOptions"></div>\r\n                    <div style="float:right;width:49%;margin:0px" dx-button="createRuleButtonOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div style="margin-top:10px;">\r\n            <div style="bottom:0;margin:5px;width:100%;" id="customColumnTestingGrid" dx-data-grid="customColumnResultGridOptions"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="columnManagementPopup" dx-popup="columnManagementPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div class="dx-fieldset">\r\n            <div class="dx-field">\r\n                <div class="dx-field-label">Name</div>\r\n                <div class="dx-field-value">\r\n                    <div dx-text-box="columnManagementColumnNameTextBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="dx-field">\r\n                <div class="dx-field-label">Format</div>\r\n                <div class="dx-field-value">\r\n                    <div id="columnManagementAvailableColumnsFormat" dx-select-box="columnManagementAvailableFormattingSelectBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div style="width:100%;margin-top:5px;min-height:30px;">\r\n            <div style="width:100%;margin:0px" dx-button="columnManagementValidateButtonOptions"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="columnChooserConsole" dx-popup="columnChooserPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div id="columnChooserGrid" style="margin:10px" dx-data-grid="columnChooserGridOptions"></div>\r\n        <div style="width:100%;margin-top:10px;min-height:30px;" dx-button="columnChooserValidateButtonOptions"></div>\r\n    </div>\r\n</div>\r\n');
  $templateCache.put('view.grid.flat.html', '<div id="flatGrid" dx-data-grid="flatGridOptions"></div>\r\n<div class="popup" id="conditionalFormattingConsole" dx-popup="conditionalFormattingPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div style="margin:5px;min-height:30px">\r\n            <div class="dx-fieldset">\r\n                <div class="dx-fieldset-header">Select an existing rule..</div>\r\n                <div class="dx-field">\r\n                    <div class="field-container">\r\n                        <div style="float:left;width:50%;" id="existingConditionalFormattingRules" dx-select-box="existingConditionalFormattingRulesSelectBoxOptions"></div>\r\n                        <div style="float:right;width:20%;" dx-button="deleteExistingRuleButtonOptions"></div>\r\n                        <div style="float:right;width:20%;" dx-button="loadExistingRuleButtonOptions"></div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class="dx-fieldset">\r\n                <div class="dx-fieldset-header">...or create a new one</div>\r\n                <div class="dx-field">\r\n                    <div class="field-container">\r\n                        <div style="float:left;width:49%;margin-right:5px;" id="conditionFormatingTargetColumn" dx-select-box="conditionalFormatingAvailableTargetColumnsOptions"></div>\r\n                        <div style="float:right;width:50%;" dx-select-box="consitionalFormattingAvailableColumnsSelectBoxOptions"></div>\r\n                    </div>\r\n                    <div style="float:left;width:100%;margin-top:5px;" dx-text-box="conditionalFormatingExpressionTextBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="field-container">\r\n                <div style="margin:5px;float:left;width:65%;">\r\n                    <div style="top:50px;margin:5px;width:100%;" id="ruleTestingGrid" dx-data-grid="conditionalFormattingResultGridPopupOptions"></div>\r\n                </div>\r\n                <div style="margin:5px;float:right;width:30%;">\r\n                    <div id="conditionalFormattingRuleList" dx-list="rulesListOptions"></div>\r\n                    <div style="margin-top:10px;" dx-color-box="conditionalFormattingColorBox"></div>\r\n                    <div style="margin-top:10px;" dx-select-box="availableIconsSelectBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="field-container">\r\n                <div style="float:left;width:48%;margin-bottom:20px;" dx-button="conditionalFormattingTestExpressionButtonOptions"></div>\r\n                <div style="float:right;width:48%;margin-bottom:20px;" dx-button="createConditionalFormattingButtonOptions"></div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="customColumnConsole" dx-popup="customColumnPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div class="dx-fieldset">\r\n            <div class="dx-fieldset-header">Select an existing custom column...</div>\r\n            <div class="dx-field">\r\n                <div style="width:100%;min-height:30px;">\r\n                    <div style="float:left;width:40%;" id="existingCustomColumns" dx-select-box="existingCustomColumnsSelectBoxOptions"></div>\r\n                    <div style="float:right;width:28%;margin:0px;" dx-button="deleteExistingCustomColumnButtonOptions"></div>\r\n                    <div style="float:right;width:27%;margin:0px 5px 0px 0px;" dx-button="loadExistingCustomColumnButtonOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class="dx-fieldset">\r\n            <div class="dx-fieldset-header">...or create a new one</div>\r\n            <div class="dx-field">\r\n                <div style="width:100%;min-height:30px;">\r\n                    <div style="float:left;width:25%;margin-right:5px;" id="customColumnColumnName" dx-text-box="customColumnNameTextBoxOptions"></div>\r\n                    <div style="float:left;width:35%;" id="customColumnAvailableColumnsFormat" dx-select-box="customColumnAvailableFormattingSelectBoxOptions"></div>\r\n                    <div style="float:right;width:35%;" id="customColumnAvailableColumns" dx-select-box="customColumnAvailableColumnsSelectBoxOptions"></div>\r\n                </div>\r\n                <div style="width:100%;" dx-text-box="customColumnExpressionTextBoxOptions"></div>\r\n                <div style="width:100%;margin-top:5px;min-height:30px;">\r\n                    <div style="float:left;width:50%;margin:0px 5px 0px 0px;" dx-button="customColumnTestExpressionButtonOptions"></div>\r\n                    <div style="float:right;width:49%;margin:0px" dx-button="createRuleButtonOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div style="margin-top:10px;">\r\n            <div style="bottom:0;margin:5px;width:100%;" id="customColumnTestingGrid" dx-data-grid="customColumnResultGridOptions"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="columnManagementPopup" dx-popup="columnManagementPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div class="dx-fieldset">\r\n            <div class="dx-field">\r\n                <div class="dx-field-label">Name</div>\r\n                <div class="dx-field-value">\r\n                    <div dx-text-box="columnManagementColumnNameTextBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="dx-field">\r\n                <div class="dx-field-label">Format</div>\r\n                <div class="dx-field-value">\r\n                    <div id="columnManagementAvailableColumnsFormat" dx-select-box="columnManagementAvailableFormattingSelectBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div style="width:100%;margin-top:5px;min-height:30px;">\r\n            <div style="width:100%;margin:0px" dx-button="columnManagementValidateButtonOptions"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="columnChooserConsole" dx-popup="columnChooserPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div id="columnChooserGrid" style="margin:10px" dx-data-grid="columnChooserGridOptions"></div>\r\n        <div style="width:100%;margin-top:10px;min-height:30px;" dx-button="columnChooserValidateButtonOptions"></div>\r\n    </div>\r\n</div>\r\n\r\n');
  $templateCache.put('view.grid.tree.html', '<div id="treeGrid" dx-tree-list="treeListOptions"></div>\r\n');
  $templateCache.put('view.tree.grid.management.html', '<div class="popup" id="conditionalFormattingConsole" dx-popup="conditionalFormattingPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div style="margin:5px;min-height:30px">\r\n            <div class="dx-fieldset">\r\n                <div class="dx-fieldset-header">Select an existing rule..</div>\r\n                <div class="dx-field">\r\n                    <div class="field-container">\r\n                        <div style="float:left;width:50%;" id="existingConditionalFormattingRules" dx-select-box="existingConditionalFormattingRulesSelectBoxOptions"></div>\r\n                        <div style="float:right;width:20%;" dx-button="deleteExistingRuleButtonOptions"></div>\r\n                        <div style="float:right;width:20%;" dx-button="loadExistingRuleButtonOptions"></div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class="dx-fieldset">\r\n                <div class="dx-fieldset-header">...or create a new one</div>\r\n                <div class="dx-field">\r\n                    <div class="field-container">\r\n                        <div style="float:left;width:49%;margin-right:5px;" id="conditionFormatingTargetColumn" dx-select-box="conditionalFormatingAvailableTargetColumnsOptions"></div>\r\n                        <div style="float:right;width:50%;" dx-select-box="consitionalFormattingAvailableColumnsSelectBoxOptions"></div>\r\n                    </div>\r\n                    <div style="float:left;width:100%;margin-top:5px;" dx-text-box="conditionalFormatingExpressionTextBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="field-container">\r\n                <div style="margin:5px;float:left;width:65%;">\r\n                    <div style="top:50px;margin:5px;width:100%;" id="ruleTestingGrid" dx-data-grid="conditionalFormattingResultGridPopupOptions"></div>\r\n                </div>\r\n                <div style="margin:5px;float:right;width:30%;">\r\n                    <div id="conditionalFormattingRuleList" dx-list="rulesListOptions"></div>\r\n                    <div style="margin-top:10px;" dx-color-box="conditionalFormattingColorBox"></div>\r\n                    <div style="margin-top:10px;" dx-select-box="availableIconsSelectBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="field-container">\r\n                <div style="float:left;width:48%;margin-bottom:20px;" dx-button="conditionalFormattingTestExpressionButtonOptions"></div>\r\n                <div style="float:right;width:48%;margin-bottom:20px;" dx-button="createConditionalFormattingButtonOptions"></div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="customColumnConsole" dx-popup="customColumnPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div class="dx-fieldset">\r\n            <div class="dx-fieldset-header">Select an existing custom column...</div>\r\n            <div class="dx-field">\r\n                <div style="width:100%;min-height:30px;">\r\n                    <div style="float:left;width:40%;" id="existingCustomColumns" dx-select-box="existingCustomColumnsSelectBoxOptions"></div>\r\n                    <div style="float:right;width:28%;margin:0px;" dx-button="deleteExistingCustomColumnButtonOptions"></div>\r\n                    <div style="float:right;width:27%;margin:0px 5px 0px 0px;" dx-button="loadExistingCustomColumnButtonOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div class="dx-fieldset">\r\n            <div class="dx-fieldset-header">...or create a new one</div>\r\n            <div class="dx-field">\r\n                <div style="width:100%;min-height:30px;">\r\n                    <div style="float:left;width:25%;margin-right:5px;" id="customColumnColumnName" dx-text-box="customColumnNameTextBoxOptions"></div>\r\n                    <div style="float:left;width:35%;" id="customColumnAvailableColumnsFormat" dx-select-box="customColumnAvailableFormattingSelectBoxOptions"></div>\r\n                    <div style="float:right;width:35%;" id="customColumnAvailableColumns" dx-select-box="customColumnAvailableColumnsSelectBoxOptions"></div>\r\n                </div>\r\n                <div style="width:100%;" dx-text-box="customColumnExpressionTextBoxOptions"></div>\r\n                <div style="width:100%;margin-top:5px;min-height:30px;">\r\n                    <div style="float:left;width:50%;margin:0px 5px 0px 0px;" dx-button="customColumnTestExpressionButtonOptions"></div>\r\n                    <div style="float:right;width:49%;margin:0px" dx-button="createRuleButtonOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div style="margin-top:10px;">\r\n            <div style="bottom:0;margin:5px;width:100%;" id="customColumnTestingGrid" dx-data-grid="customColumnResultGridOptions"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="columnManagementPopup" dx-popup="columnManagementPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div class="dx-fieldset">\r\n            <div class="dx-field">\r\n                <div class="dx-field-label">Name</div>\r\n                <div class="dx-field-value">\r\n                    <div dx-text-box="columnManagementColumnNameTextBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n            <div class="dx-field">\r\n                <div class="dx-field-label">Format</div>\r\n                <div class="dx-field-value">\r\n                    <div id="columnManagementAvailableColumnsFormat" dx-select-box="columnManagementAvailableFormattingSelectBoxOptions"></div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <div style="width:100%;margin-top:5px;min-height:30px;">\r\n            <div style="width:100%;margin:0px" dx-button="columnManagementValidateButtonOptions"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<div class="popup" id="columnChooserConsole" dx-popup="columnChooserPopupOptions">\r\n    <div data-options="dxTemplate: { name:\'info\' }">\r\n        <div id="columnChooserGrid" style="margin:10px" dx-data-grid="columnChooserGridOptions"></div>\r\n        <div style="width:100%;margin-top:10px;min-height:30px;" dx-button="columnChooserValidateButtonOptions"></div>\r\n    </div>\r\n</div>\r\n');
}]);
'use strict';

dxGridExtension.factory('conditionalFormattingConfiguration', function ($log) {

    function applyConditionalFormattingExpressionOnCell(cell, rule, dataSource) {

        try {
            if (cell.rowType == 'data' && !dxGridExtensions.isUndefinedOrNull(rule) && !dxGridExtensions.isUndefinedOrNull(cell.value) && rule.target == cell.column.dataField && cell.data != null) {

                var self = this;

                if (rule.isExpressionBased) {

                    var expression = rule.expression;
                    var replacement = {};
                    var processedExpression = expression;

                    var row = cell.row.data;

                    _.forEach(row, function (value, key) {

                        dxGridExtensions.initFormulas(self);

                        var replacement = typeof value === "string" ? "'" + value + "'" : value;
                        processedExpression = processedExpression.split('[' + key + ']').join(" " + replacement + " ");
                    });

                    var result = eval(processedExpression);

                    if (result) rule.formatting(cell, rule);
                } else {
                    rule.formatting(cell, rule, dataSource);
                }
            };
        } catch (e) {
            $log.error(e);
        }
    };

    //refacto : otherway arround, list of rules to menu 
    var rules = [{
        "key": "Auto set",
        "items": [{
            text: "Proportional Bars",
            isExpressionBased: false,
            formatting: function formatting(options, rule, dataSource) {

                if (options.column.dataType != 'number') return;

                if (options.value < 0) return;

                var total = _.sumBy(dataSource, function (o) {
                    return o[rule.target] != null && o[rule.target] > 0 ? o[rule.target] : 0;
                });

                var fieldHtml = "<div><div class='formatting bar superpose' style='background:" + rule.color + ";width:" + options.value / total * 100 + "%;''></div> <div class='formatting superpose'  style='z-index: 10;margin-top:-16px;'>" + options.text + "  </div></div>";

                options.cellElement.html(fieldHtml);
            }
        }, {
            text: "Up/Down colors",
            isExpressionBased: false,
            formatting: function formatting(options, rule) {

                if (options.column.dataType != 'number') return;

                if (options.value > 0) {
                    options.cellElement.css("color", "green");
                } else {

                    options.cellElement.css("color", "red");
                }
            }
        }, {
            text: "Up/Down icon",
            isExpressionBased: false,
            formatting: function formatting(options, rule) {

                if (options.column.dataType != 'number') return;

                if (options.value > 0) {
                    options.cellElement.append('<span class="cb cb-chevron-up" style="color:green;"></span>');
                } else {

                    options.cellElement.append('<span class="cb cb-chevron-down" style="color:red;"></span>');
                }
            }
        }]
    }, {
        "key": "Expression based",
        "items": [{
            text: "Text color",
            isExpressionBased: true,
            formatting: function formatting(options, rule) {
                $(options.cellElement[0]).css("color", rule.color);
            }
        }, {
            text: "Background Color",
            isExpressionBased: true,
            formatting: function formatting(options, rule) {
                $(options.cellElement[0]).css("background-color", rule.color);
            }
        }, {
            text: "Icon",
            isExpressionBased: true,
            formatting: function formatting(options, rule) {
                options.cellElement.append('<span class="' + rule.icon + '" style="color: ' + rule.color + ';"></span>');
            }
        }]
    }];

    var icons = [{
        name: "Arrow up",
        css: 'cb cb-arrow-up'
    }, {
        name: "Arrow down",
        css: 'cb cb-arrow-down'
    }, {
        name: "Chevron up",
        css: 'cb cb-chevron-up'
    }, {
        name: "Chevron down",
        css: 'cb cb-chevron-down'
    }, {
        name: "Spin up",
        css: 'cb cb-spin-up'
    }, {
        name: "Spin down",
        css: 'cb cb-spin-down'
    }, {
        name: "Favorites",
        css: 'cb cb-favorites'
    }, {
        name: "Like",
        css: 'cb cb-like'
    }, {
        name: "Info",
        css: 'cb cb-info'
    }, {
        name: "Todo",
        css: 'cb cb-todo'
    }];

    var getRuleTemplate = function getRuleTemplate(name) {

        var allRules = getAllRules();

        var template = _.find(allRules, function (rule) {
            return rule.text === name;
        });

        return _.clone(template);
    };

    var getRuleFromdescriptor = function getRuleFromdescriptor(descriptor) {

        var rule = getRuleTemplate(descriptor.text);

        return _.extend(rule, descriptor);
    };

    var getAllRules = function getAllRules() {
        return _.transform(rules, function (result, group) {
            _.each(group.items, function (rule) {
                result.push(rule);
            }, []);
        });
    };

    var createRule = function createRule(name, target, expression, color, icon) {

        var rule = getRuleTemplate(name);

        if (dxGridExtensions.isUndefinedOrNull(rule)) throw new Error("Rule " + name + " does not exist");

        rule.target = target;
        rule.expression = expression;
        rule.color = color;
        rule.icon = icon;

        return rule;
    };

    return {
        getRuleFromdescriptor: getRuleFromdescriptor,
        createRule: createRule,
        applyConditionalFormattingExpressionOnCell: applyConditionalFormattingExpressionOnCell,
        getAllRules: getAllRules,
        availableRules: rules,
        availableIcons: icons
    };
});
"use strict";

dxGridExtension.service('customColumnConfiguration', function ($log) {

    this.createCustomColumn = function (name, expression, format) {

        return {
            name: name,
            expression: expression,
            format: format
        };
    };

    this.computeCustomColumn = function (rule, datasource) {

        try {

            var self = this;
            var expression = rule.expression;
            var replacement = {};
            var processedExpression = expression;

            _.forEach(datasource, function (item) {

                dxGridExtensions.initFormulas(self);

                _.forEach(item, function (value, key) {

                    var replacement = typeof value === "string" ? "'" + value + "'" : value;
                    processedExpression = processedExpression.split('[' + key + ']').join(" " + replacement + " ");
                });

                var result = eval(processedExpression);
                item[rule.name] = result;
                processedExpression = expression;
            });
        } catch (e) {
            $log.error(e);
        }
    };

    this.customColumnFormats = [{
        text: "string",
        value: {
            dataType: "string",
            format: { type: '', precision: 0 }
        }
    }, {
        text: "integer",
        value: {
            dataType: "number",
            format: { type: 'fixedpoint', precision: 0 }
        }
    }, {
        text: "percentage 2",
        value: {
            dataType: "number",
            format: { type: 'percent', precision: 2 }
        }
    }, {
        text: "percentage 5",
        value: {
            dataType: "number",
            format: { type: 'percent', precision: 5 }
        }
    }, {
        text: "decimal 2",
        value: {
            dataType: "number",
            format: { type: 'fixedpoint', precision: 2 }
        }
    }, {
        text: "decimal 5",
        value: {
            dataType: "number",
            format: { type: 'fixedpoint', precision: 5 }
        }
    }, {
        text: "boolean",
        value: {
            dataType: "boolean",
            format: { type: '', precision: 0 }
        }
    }];
});